# Colleague's Toyota Failover Fix - Claude Code Prompt

**Return to Claude Code with this exact prompt:**

```
I need to implement simple endpoint failover logic that tries all endpoints in order before giving up.

PROBLEM IDENTIFIED: System gives "No available endpoints" when individual endpoints fail instead of trying other healthy endpoints.

CURRENT BROKEN BEHAVIOR: 
- Chainstack fails → System reports "no available endpoints"
- Helius rate limited → System reports "no available endpoints"
- System should try next endpoint immediately

## SINGLE FOCUS: Implement Simple Endpoint Rotation

TASK: Replace current endpoint selection with a simple loop that tries all endpoints in order, skipping OPEN circuit breakers.

### Explicit File to Modify:
**ONLY**: `src/detection/transport/rpc-connection-pool.js` - Replace call() method endpoint selection logic

### Exact Implementation Required:

Replace the current endpoint selection logic with this specific code:

```javascript
// inside RpcConnectionPool.call() method
async call(method, params = [], opts = {}) {
  const budgetMs = opts.failoverBudgetMs ?? 5000; // meet "<5s failover" goal
  const start = Date.now();
  let lastErr;
  
  // round-robin cursor lives on the instance
  if (typeof this._rr !== 'number') this._rr = 0;
  
  for (let attempts = 0; attempts < this.endpoints.length &&
                         (Date.now() - start) < budgetMs; attempts++) {
    // pick next non-OPEN endpoint (skip OPEN circuit breakers)
    let ep = null;
    for (let i = 0; i < this.endpoints.length; i++) {
      const cand = this.endpoints[(this._rr + i) % this.endpoints.length];
      if (cand.breaker.state !== 'OPEN') { 
        ep = cand; 
        this._rr = (this._rr + i + 1) % this.endpoints.length; 
        break; 
      }
    }
    if (!ep) break; // all OPEN, bail fast
    
    try {
      const res = await this._callOn(ep, method, params, opts);
      return res; // success → return immediately
    } catch (err) {
      lastErr = err;
      // On any error (429, network, timeout, 5xx): immediately try next endpoint
      // No sleep, no complex logic, just move on
      continue;
    }
  }
  
  // Clear error message when we really run out
  throw new Error(`All endpoints failed within ${Date.now() - start}ms (budget ${budgetMs}ms). Last error: ${lastErr?.message || 'unknown'}`);
}
```

### Incremental Implementation Process:

**Step 1**: Locate existing call() method in RpcConnectionPool class
**Step 2**: Replace endpoint selection logic with the simple loop above  
**Step 3**: Test with Helius disabled - should automatically use Chainstack
**Step 4**: Test with Chainstack disabled - should automatically use Public RPC  
**Step 5**: Test with all endpoints healthy - should work normally

### Clear Success Criteria:

**Failover Requirements**:
- When Helius fails → automatically tries Chainstack within 5 seconds
- When Chainstack fails → automatically tries Public RPC within 5 seconds
- System works as long as any one endpoint is healthy
- No more "No available endpoints" unless ALL endpoints are actually OPEN
- Round-robin rotation across healthy endpoints

**Performance Requirements**:
- Failover completes within 5 second budget (opts.failoverBudgetMs)
- OPEN circuit breakers are skipped automatically  
- Successful requests return immediately (no unnecessary retries)
- Error messages include timing and specific failure details
- Existing performance maintained when all endpoints healthy

### Implementation Constraints:

**Keep Simple**:
- No complex health scoring or weighting
- No exponential backoff or retry delays
- No sophisticated load balancing algorithms
- Just try next endpoint immediately on any failure

**Integration Requirements**:
- Use existing circuit breaker state (cand.breaker.state !== 'OPEN')
- Call existing _callOn() method for actual RPC execution
- Maintain existing error handling and logging patterns
- Keep existing method signature and options structure

### Testing Requirements:
- Test normal operation with all endpoints healthy
- Test failover when primary endpoint returns 429 errors
- Test failover when primary endpoint has network timeouts
- Test behavior when all circuit breakers are OPEN
- Verify 5-second failover budget is enforced

### Expected Changes:

**Modified Method**: Replace RpcConnectionPool.call() endpoint selection
- Remove complex endpoint selection algorithms
- Replace with simple round-robin loop
- Add 5-second failover budget enforcement
- Skip OPEN circuit breakers automatically
- Clear error messages with timing information

**Test Validation**: Create simple test to verify failover
- Disable Helius endpoint, verify Chainstack used
- Disable Chainstack endpoint, verify Public RPC used
- Measure failover timing is under 5 seconds
- Confirm no "No available endpoints" errors when some endpoints healthy

### If Implementation Fails:
1. Verify _callOn() method exists and works correctly
2. Check that endpoints array and circuit breaker states are accessible
3. Ensure round-robin cursor (_rr) is properly maintained
4. Test simple loop logic in isolation before integration

CRITICAL REQUIREMENTS:
- Failover must complete within 5 seconds for Session 3C-1 requirements
- Must eliminate "No available endpoints" when some endpoints are healthy
- Circuit breaker OPEN states must be respected (skip those endpoints)
- Implementation must be simple - no complex algorithms
- Error messages must include timing and specific failure information

SUCCESS CRITERIA SUMMARY:
- Helius failure → automatic Chainstack retry within 5 seconds
- Chainstack failure → automatic Public RPC retry within 5 seconds
- System works with any single healthy endpoint
- Clear error messages only when all endpoints actually failed
- Ready to pass Session 3C-1 critical failure scenarios
```

## Your Post-Implementation Process

After Claude Code implements the colleague's failover logic:

**Step 1: Test Basic Failover**
```bash
# Test that failover actually works
node -e "
// Test script to verify endpoint failover
// Simulate Helius failure, should try Chainstack
// Simulate Chainstack failure, should try Public RPC
"
```

**Step 2: Verify Session 3C-1 Improvements**  
```bash
# Re-run critical failure scenarios
node scripts/test-critical-failures.js

# Check that Chainstack and Helius failure scenarios now pass
grep -i "chainstack.*recovery.*success\|helius.*recovery.*success" critical-failure-results.txt
```

**Step 3: Validate 5-Second Budget**
```bash
# Test failover timing
node -e "
// Measure actual failover time under various scenarios
// Should complete within 5 seconds as required
"

# Check timing in test results
grep -i "failover.*time\|budget.*5.*second" test-timing-results.txt
```

This prompt implements exactly your colleague's 20-line solution without the Ferrari complexity that Claude Code initially proposed.