PROMPT 2C: Endpoint Selector Component Testing
SINGLE FOCUS: Create comprehensive test suite for extracted endpoint-selector.js component
EXPLICIT FILE PATHS:

Target: tests/unit/endpoint-selector.test.js
Component Under Test: src/detection/transport/endpoint-selector.js

INCREMENTAL IMPLEMENTATION PROCESS:
Step 1: Create test framework and mock endpoints for EndpointSelector class isolated testing
Step 2: Test round-robin distribution accuracy across multiple healthy endpoints with large sample sizes
Step 3: Test health-based endpoint filtering and automatic exclusion of unhealthy endpoints
Step 4: Test failover and recovery scenarios (endpoints going down and coming back up)
Step 5: Test weighted selection, priority handling, and concurrent selection safety
CLEAR SUCCESS CRITERIA:
Load Balancing Requirements:

Round-robin distribution: Even distribution across healthy endpoints within Â±5% variance
Health filtering: Unhealthy endpoints skipped 100% of time during selection process
Failover speed: Switch to healthy endpoint within 1 selectEndpoint() call after failure
Recovery detection: Include recovered endpoints in rotation within 30 seconds of recovery

Performance Requirements:

Selection latency: <0.5ms per selectEndpoint() call including health checking logic
Memory overhead: <10KB for 10 endpoints with complete health tracking and statistics
Health check accuracy: 100% correct healthy/unhealthy detection and state management
Concurrent selection safety: 1000 concurrent selectEndpoint() calls without conflicts

REQUIREMENTS-BASED VALIDATION:
Measure These Metrics:

Distribution evenness (target: within 5% even distribution across all healthy endpoints)
Health filtering accuracy (target: 100% of unhealthy endpoints properly avoided)
Failover detection speed (target: <1 selection call to detect and handle endpoint failure)
Recovery inclusion time (target: <30 seconds to include recovered endpoint)
Selection latency performance (target: <0.5ms per selectEndpoint() call)

Mock Endpoint Testing Approach:

Create mock endpoints that can be dynamically marked healthy or unhealthy
Test selection patterns with various endpoint health configurations and transitions
Validate endpoint statistics collection, reporting, and health state management
Test edge cases (all endpoints down, single endpoint up, rapid health transitions)