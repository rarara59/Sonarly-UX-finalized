# PROMPT RN3-CORRECTED: WebSocket Live Streaming Test

## SINGLE FOCUS
Validate streaming stability using proper WebSocket client with fixed-interval monitoring

## EXPLICIT FILE PATHS
- **CREATE**: `scripts/test-websocket-streaming-corrected.js`
- **CREATE**: `scripts/websocket-stream-monitor.js`
- **CREATE**: `results/streaming-soak-results.json` (output)
- **IMPORT**: Detection pipeline from refactored system
- **IMPORT**: `@solana/web3.js` for WebSocket Connection

## INCREMENTAL IMPLEMENTATION

### Step 1: WebSocket Client Setup
Use proper WebSocket Connection instead of HTTP RPC calls:
```javascript
import { Connection, PublicKey } from '@solana/web3.js';

class WebSocketStreamTest {
  constructor(wsEndpoint, detectionSystem) {
    this.wsConnection = new Connection(wsEndpoint, {
      wsEndpoint: wsEndpoint.replace('https:', 'wss:'),
      commitment: 'processed'
    });
    this.detectionSystem = detectionSystem;
    this.subscriptions = [];
    this.streamMetrics = {
      eventsReceived: 0,
      eventsProcessed: 0,
      eventsDropped: 0,
      processingErrors: 0
    };
  }
  
  async setupProgramLogSubscriptions() {
    try {
      // Subscribe to Raydium AMM v4 logs
      const raydiumSub = this.wsConnection.onLogs(
        new PublicKey('RAYDIUM_AMM_V4_PROGRAM_ID'),
        (logs, context) => {
          this.handleLogEvent('raydium', logs, context);
        },
        'processed'
      );
      
      // Subscribe to SPL Token program logs
      const tokenSub = this.wsConnection.onLogs(
        new PublicKey('SPL_TOKEN_PROGRAM_ID'),
        (logs, context) => {
          this.handleLogEvent('token', logs, context);
        },
        'processed'
      );
      
      this.subscriptions = [raydiumSub, tokenSub];
      console.log('WebSocket subscriptions established:', this.subscriptions);
      
      return { raydiumSub, tokenSub };
      
    } catch (error) {
      console.error('Failed to setup WebSocket subscriptions:', error);
      throw error;
    }
  }
}
```

### Step 2: Stream Processing with Queue Management
Process log events with backpressure monitoring:
```javascript
class StreamProcessor {
  constructor(maxQueueSize = 10000) {
    this.processingQueue = [];
    this.maxQueueSize = maxQueueSize;
    this.processing = false;
    this.queueStats = {
      maxDepth: 0,
      avgDepth: 0,
      samples: []
    };
  }
  
  async handleLogEvent(source, logs, context) {
    this.streamMetrics.eventsReceived++;
    
    // Check for backpressure
    if (this.processingQueue.length >= this.maxQueueSize) {
      this.streamMetrics.eventsDropped++;
      console.warn('Queue full, dropping event:', {
        queueDepth: this.processingQueue.length,
        source
      });
      return;
    }
    
    // Add to processing queue
    this.processingQueue.push({
      timestamp: Date.now(),
      source,
      logs,
      context,
      slot: context.slot
    });
    
    // Start processing if not already running
    if (!this.processing) {
      this.startProcessing();
    }
  }
  
  async startProcessing() {
    this.processing = true;
    
    while (this.processingQueue.length > 0) {
      const event = this.processingQueue.shift();
      await this.processLogEventSafely(event);
    }
    
    this.processing = false;
  }
  
  async processLogEventSafely(event) {
    const startTime = Date.now();
    
    try {
      // Parse log event
      const parsed = await this.parseLogEvent(event.logs);
      
      // Enrich with 1-2 RPC calls
      const enriched = await this.enrichEventData(parsed, event.context);
      
      // Run through detection pipeline
      await this.detectionSystem.processEvent(enriched);
      
      this.streamMetrics.eventsProcessed++;
      
    } catch (error) {
      this.streamMetrics.processingErrors++;
      console.error('Error processing log event:', error.message);
    }
    
    const processingTime = Date.now() - startTime;
    this.recordProcessingTime(processingTime);
  }
}
```

### Step 3: Fixed-Interval Monitoring System
Replace modulo sampling with proper setInterval:
```javascript
class StreamMonitor {
  constructor(streamProcessor) {
    this.streamProcessor = streamProcessor;
    this.monitoringActive = false;
    this.samples = [];
    this.startTime = Date.now();
    this.memoryBaseline = process.memoryUsage();
  }
  
  startMonitoring() {
    this.monitoringActive = true;
    
    // Sample every 30 seconds
    this.monitoringInterval = setInterval(() => {
      this.sampleMetrics();
    }, 30000);
    
    console.log('Stream monitoring started - sampling every 30 seconds');
  }
  
  sampleMetrics() {
    const currentTime = Date.now();
    const currentMemory = process.memoryUsage();
    const queueDepth = this.streamProcessor.processingQueue.length;
    
    const sample = {
      timestamp: currentTime,
      elapsed_minutes: (currentTime - this.startTime) / 60000,
      queue_depth: {
        current: queueDepth,
        avg: this.calculateAverageQueueDepth(),
        max: this.streamProcessor.queueStats.maxDepth
      },
      stream_rates: {
        in_rate: this.calculateIncomingRate(),
        out_rate: this.calculateProcessingRate(),
        drop_rate: this.calculateDropRate()
      },
      memory: {
        rss_mb: Math.round(currentMemory.rss / 1024 / 1024),
        heap_used_mb: Math.round(currentMemory.heapUsed / 1024 / 1024),
        growth_mb: Math.round((currentMemory.rss - this.memoryBaseline.rss) / 1024 / 1024)
      },
      circuit_breaker: {
        state: this.getCircuitBreakerState(),
        trips_total: this.getCircuitBreakerTrips()
      }
    };
    
    this.samples.push(sample);
    
    // Update queue stats
    this.streamProcessor.queueStats.maxDepth = Math.max(
      this.streamProcessor.queueStats.maxDepth,
      queueDepth
    );
    
    console.log('Stream sample:', sample);
  }
  
  stopMonitoring() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringActive = false;
      console.log('Stream monitoring stopped');
    }
  }
}
```

### Step 4: Backpressure Detection and Management
Monitor queue growth and processing rates:
```javascript
detectBackpressure() {
  const recentSamples = this.samples.slice(-5); // Last 5 samples (2.5 minutes)
  
  if (recentSamples.length < 3) return false;
  
  // Check for sustained queue growth
  const queueGrowthRate = this.calculateQueueGrowthRate(recentSamples);
  const avgProcessingRate = this.calculateAverageProcessingRate(recentSamples);
  const avgIncomingRate = this.calculateAverageIncomingRate(recentSamples);
  
  const backpressure = {
    detected: queueGrowthRate > 5 || avgIncomingRate > avgProcessingRate * 1.2,
    queue_growth_rate: queueGrowthRate,
    processing_rate: avgProcessingRate,
    incoming_rate: avgIncomingRate,
    queue_utilization: this.streamProcessor.processingQueue.length / this.streamProcessor.maxQueueSize
  };
  
  if (backpressure.detected) {
    console.warn('Backpressure detected:', backpressure);
  }
  
  return backpressure;
}
```

### Step 5: Circuit Breaker Monitoring During Stream
Track circuit breaker behavior throughout 60-minute test:
```javascript
monitorCircuitBreakerBehavior() {
  const cbMonitor = {
    transitions: [],
    tripsPerMinute: [],
    recoveryTimes: [],
    currentState: 'CLOSED'
  };
  
  // Monitor state changes
  this.circuitBreaker.on('stateChange', (from, to, endpoint) => {
    const transition = {
      timestamp: Date.now(),
      from,
      to,
      endpoint,
      reason: this.circuitBreaker.getLastError()?.message
    };
    
    cbMonitor.transitions.push(transition);
    cbMonitor.currentState = to;
    
    if (to === 'OPEN') {
      this.recordTripTime();
    } else if (from === 'HALF_OPEN' && to === 'CLOSED') {
      this.recordRecoveryTime(transition.timestamp);
    }
  });
  
  // Sample trips per minute
  setInterval(() => {
    const recentTrips = this.getTripsInLastMinute();
    cbMonitor.tripsPerMinute.push({
      timestamp: Date.now(),
      trips: recentTrips
    });
  }, 60000);
  
  return cbMonitor;
}
```

### Step 6: 60-Minute Soak Test with Stream Drop Detection
Run complete soak test with connection monitoring:
```javascript
async run60MinuteSoakTest() {
  const testDuration = 60 * 60 * 1000; // 60 minutes
  const startTime = Date.now();
  
  console.log('Starting 60-minute WebSocket soak test...');
  
  // Setup WebSocket subscriptions
  const subscriptions = await this.setupProgramLogSubscriptions();
  
  // Start monitoring
  this.streamMonitor.startMonitoring();
  const cbMonitor = this.monitorCircuitBreakerBehavior();
  
  // Monitor for connection drops
  this.wsConnection.onDisconnect(() => {
    console.warn('WebSocket connection dropped at:', new Date());
    this.streamMetrics.connectionDrops++;
  });
  
  // Run for full duration
  await new Promise(resolve => {
    setTimeout(resolve, testDuration);
  });
  
  // Cleanup
  this.streamMonitor.stopMonitoring();
  this.subscriptions.forEach(sub => {
    this.wsConnection.removeOnLogsListener(sub);
  });
  
  // Generate results
  return this.generateSoakTestResults(cbMonitor);
}

generateSoakTestResults(cbMonitor) {
  const totalEvents = this.streamMetrics.eventsReceived;
  const memoryGrowth = this.streamMonitor.getFinalMemoryGrowth();
  const dropRate = this.streamMetrics.eventsDropped / totalEvents;
  const tripsPerMinute = cbMonitor.tripsPerMinute.reduce((sum, sample) => sum + sample.trips, 0) / 60;
  
  return {
    test_duration_minutes: 60,
    stream_performance: {
      events_received: this.streamMetrics.eventsReceived,
      events_processed: this.streamMetrics.eventsProcessed,
      events_dropped: this.streamMetrics.eventsDropped,
      drop_rate_pct: Math.round(dropRate * 100),
      processing_success_rate_pct: Math.round((1 - this.streamMetrics.processingErrors / this.streamMetrics.eventsProcessed) * 100)
    },
    memory_analysis: {
      growth_mb: memoryGrowth,
      drift_mb_per_hour: memoryGrowth, // 60-minute test
      stable: memoryGrowth <= 50
    },
    queue_analysis: {
      max_depth: this.streamProcessor.queueStats.maxDepth,
      avg_depth: this.calculateAverageQueueDepth(),
      backpressure_events: this.countBackpressureEvents()
    },
    circuit_breaker_analysis: {
      total_transitions: cbMonitor.transitions.length,
      trips_per_minute_avg: tripsPerMinute,
      stable: tripsPerMinute <= 2,
      recovery_successful: cbMonitor.recoveryTimes.length > 0
    }
  };
}
```

## CLEAR SUCCESS CRITERIA
- Memory drift ≤50MB over 60 minutes
- Stream drop rate ≤1% (connection stability)
- Queue depth oscillates but drains (no unbounded growth)
- Circuit breaker trips ≤2 per minute with successful recovery
- Processing success rate ≥95% for received events

## REQUIREMENTS-BASED VALIDATION
- **Memory Stability**: RSS growth ≤50MB/hour, no memory leaks
- **Stream Reliability**: Drop rate ≤1%, stable WebSocket connections
- **Queue Management**: Max depth <500, drains within 60s of burst
- **Circuit Breaker**: ≤2 trips/minute, successful half-open recovery
- **Processing Success**: ≥95% of events processed without errors
- **Backpressure Handling**: System handles bursts without permanent queue growth