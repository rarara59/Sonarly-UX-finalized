PROMPT 1B: Circuit Breaker Extraction
SINGLE FOCUS: Extract circuit breaker state machine from existing 2000-line RPC connection pool
EXPLICIT FILE PATHS:

Source: src/detection/transport/rpc-connection-pool.js (lines containing "circuit", "breaker", "failure", "threshold", "cooldown")
Target: src/detection/transport/circuit-breaker.js

INCREMENTAL IMPLEMENTATION PROCESS:
Step 1: Extract circuit breaker state tracking, failure counting, and timeout management logic
Step 2: Create CircuitBreaker class with CLOSED/OPEN/HALF_OPEN state machine implementation
Step 3: Test state transitions in isolation with controlled failure and success scenarios
Step 4: Test per-service isolation (multiple services with independent circuit breaker states)
Step 5: Create integration stub in original file: await circuitBreaker.execute(serviceName, fn)
CLEAR SUCCESS CRITERIA:
State Machine Requirements:

State transitions: 100% correct CLOSED → OPEN → HALF_OPEN → CLOSED transitions
Failure threshold triggering: Opens circuit after exactly N failures (configurable)
Cooldown timing: Respects configured timeout before transitioning to HALF_OPEN state
Per-service isolation: 100 different services tracked independently without interference

Performance Requirements:

State check latency: <1ms per execute() call including state machine logic
Memory per service: <1KB overhead per tracked service for state management
Recovery detection: <3 successful probes to return from HALF_OPEN to CLOSED state
Concurrent safety: 1000 concurrent execute() calls without race conditions or state corruption

Integration Requirements:

Original file compiles successfully after extraction with integration stub
Integration interface: await circuitBreaker.execute(serviceName, fn) ready for orchestrator
Export functionality: import { CircuitBreaker } from './circuit-breaker.js' works correctly
Configuration compatibility: Existing circuit breaker environment variables work unchanged

REQUIREMENTS-BASED VALIDATION:
Measure These Metrics:

State transition accuracy (target: 100% correct transitions under all scenarios)
Failure threshold precision (target: Opens within 1 failure of configured threshold)
Cooldown timing accuracy (target: Within 5% of configured timeout duration)
Per-service isolation effectiveness (target: 100 services work independently)
Concurrent execution safety (target: 1000 concurrent calls, 0 race conditions)