PHASE 0: ORCHESTRATION FRAMEWORK (3 Sequential Prompts)
Duration: 3 hours sequential execution
Dependencies: None (foundational phase)
PROMPT 0A: RpcManager Orchestrator Creation
SINGLE FOCUS: Create main RpcManager class that orchestrates all 7 components
EXPLICIT FILE PATHS:

Target: src/detection/transport/rpc-manager.js
Dependencies: Will import all 7 components (to be created in Phase 1)

INCREMENTAL IMPLEMENTATION PROCESS:
Step 1: Create RpcManager class with dependency injection constructor for all 7 components
Step 2: Implement component initialization order and lifecycle management methods
Step 3: Create main call() method that orchestrates complete component flow
Step 4: Add component failure isolation and error handling throughout request flow
Step 5: Test orchestrator with mock components to validate integration patterns
CLEAR SUCCESS CRITERIA:
Orchestration Requirements:

Component dependency injection: All 7 components properly injected via constructor
Initialization order: Components initialize in correct dependency sequence
Request flow: Requests flow through components in optimal order for trading performance
Error isolation: Individual component failures don't cascade to kill entire system

Performance Requirements:

Orchestration overhead: <10ms additional latency per request beyond component costs
Memory efficiency: Orchestrator uses <10MB overhead for component coordination
Startup time: Complete system initialization in <5 seconds from cold start
Graceful degradation: System continues with 80% capability when components fail

Component Flow Architecture:
async call(method, params, options = {}) {
  // Step 1: Rate limiting check (fail fast if over limit)
  if (!await this.tokenBucket.hasTokens()) {
    throw new RateLimitError('Rate limit exceeded');
  }

  // Step 2: Circuit breaker protection (wrap entire call chain)
  return await this.circuitBreaker.execute(`rpc_${method}`, async () => {
    
    // Step 3: Endpoint selection (choose best available endpoint)
    const endpoint = this.endpointSelector.selectEndpoint();
    
    // Step 4: Request caching (check for duplicate/cached requests)
    const cacheKey = this.generateCacheKey(method, params);
    return await this.requestCache.get(cacheKey, async () => {
      
      // Step 5: Request batching (combine with other requests if possible)
      return await this.batchManager.addRequest(method, params, async (batchedRequests) => {
        
        // Step 6: Hedged requests (parallel requests for critical calls)
        const primaryRequest = () => this.connectionPool.execute(endpoint, method, params);
        const backupRequests = this.shouldHedge(method, options) ? 
          [() => this.connectionPool.execute(this.endpointSelector.selectBackupEndpoint(), method, params)] : 
          [];
          
        return await this.hedgedManager.hedgedRequest(primaryRequest, backupRequests);
      });
    });
  });
}

REQUIREMENTS-BASED VALIDATION:
Measure These Metrics:

Component initialization success rate (target: 100% successful startup sequence)
Request orchestration latency overhead (target: <10ms beyond component costs)
Error isolation effectiveness (target: Single component failure doesn't kill system)
Memory usage for orchestration (target: <10MB coordination overhead)
Graceful degradation capability (target: 80%+ functionality with failed components)