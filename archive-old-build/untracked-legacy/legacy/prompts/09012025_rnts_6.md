# PROMPT RN6-CORRECTED: Hot Address Stability with Resource Monitoring

## SINGLE FOCUS
Validate RPC pool stability using hot address sampling with per-method latency tracking and socket monitoring

## EXPLICIT FILE PATHS
- **CREATE**: `scripts/test-hot-address-stability-corrected.js`
- **CREATE**: `scripts/hot-address-sampler-corrected.js`
- **CREATE**: `scripts/resource-monitor.js`
- **CREATE**: `data/hot-addresses-refreshed.json` (curated and recent)
- **CREATE**: `results/hot-address-stability-results.json` (output)
- **IMPORT**: RPC pool components with connection monitoring

## INCREMENTAL IMPLEMENTATION

### Step 1: Refreshed Hot Address List
Create recently validated hot address list with categorization:
```javascript
const refreshedHotAddresses = {
  high_volume_mints: [
    {
      address: 'So11111111111111111111111111111111111111112', // Wrapped SOL
      name: 'WSOL',
      type: 'native',
      last_verified: '2024-08-31',
      activity_level: 'extreme'
    },
    {
      address: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', // BONK
      name: 'BONK',
      type: 'meme',
      last_verified: '2024-08-31',
      activity_level: 'high'
    },
    {
      address: 'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm', // WIF
      name: 'WIF',
      type: 'meme',
      last_verified: '2024-08-31',
      activity_level: 'high'
    }
  ],
  active_pools: [
    {
      address: '58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2', // SOL/USDC Raydium
      name: 'SOL-USDC',
      dex: 'raydium',
      last_verified: '2024-08-31',
      activity_level: 'extreme'
    },
    {
      address: '7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX', // BONK/SOL
      name: 'BONK-SOL',
      dex: 'raydium',
      last_verified: '2024-08-31',
      activity_level: 'high'
    }
  ],
  whale_wallets: [
    {
      address: 'GDyn7ukbuKXyN3BMe8HJyXB9qzD4h8rcPxrJ8mF4EUbf',
      name: 'High Volume Trader',
      type: 'trader',
      last_verified: '2024-08-31',
      activity_level: 'high'
    }
  ]
};
```

### Step 2: Rate-Limited Method Sampler
Create sampler with method-specific rate limiting and filtering:
```javascript
class HotAddressSamplerCorrected {
  constructor(hotAddresses, rpcPool) {
    this.addresses = hotAddresses;
    this.rpcPool = rpcPool;
    this.methodRotation = 0;
    this.methods = [
      {
        name: 'getAccountInfo',
        applicable: ['mints', 'pools', 'wallets'],
        params: (address) => [address, { encoding: 'base64' }],
        rateLimit: 10 // per minute
      },
      {
        name: 'getTokenLargestAccounts',
        applicable: ['mints'],
        params: (address) => [address],
        rateLimit: 5 // per minute
      },
      {
        name: 'getBalance',
        applicable: ['wallets'],
        params: (address) => [address, { commitment: 'processed' }],
        rateLimit: 15 // per minute
      },
      {
        name: 'getProgramAccounts',
        applicable: ['mints'],
        params: (address) => [
          'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA', // SPL Token Program
          {
            filters: [
              { dataSize: 165 },
            ],
            dataSlice: { offset: 0, length: 32 }
          }
        ],
        rateLimit: 1, // per minute - heavy operation
        weight: 5 // Count as 5 requests for resource tracking
      }
    ];
    this.methodUsage = new Map();
    this.latencyByMethod = new Map();
  }
  
  getNextMethodForAddress(address, addressType) {
    const applicableMethods = this.methods.filter(method =>
      method.applicable.includes(addressType)
    );
    
    if (applicableMethods.length === 0) return null;
    
    // Find method that hasn't hit rate limit
    for (let i = 0; i < applicableMethods.length; i++) {
      const method = applicableMethods[this.methodRotation % applicableMethods.length];
      this.methodRotation++;
      
      if (this.canUseMethod(method)) {
        this.recordMethodUsage(method.name);
        return method;
      }
    }
    
    return null; // All methods rate limited
  }
  
  canUseMethod(method) {
    const now = Date.now();
    const usage = this.methodUsage.get(method.name) || { count: 0, resetTime: now + 60000 };
    
    // Reset counter if minute has passed
    if (now > usage.resetTime) {
      usage.count = 0;
      usage.resetTime = now + 60000;
    }
    
    return usage.count < method.rateLimit;
  }
  
  recordMethodUsage(methodName) {
    const now = Date.now();
    const usage = this.methodUsage.get(methodName) || { count: 0, resetTime: now + 60000 };
    usage.count++;
    this.methodUsage.set(methodName, usage);
  }
}
```

### Step 3: Resource Monitor with Socket Tracking
Monitor connection pool resources and socket usage:
```javascript
class ResourceMonitorCorrected {
  constructor(rpcPool, connectionPool) {
    this.rpcPool = rpcPool;
    this.connectionPool = connectionPool;
    this.baseline = this.captureResourceBaseline();
    this.samples = [];
    this.monitoring = false;
  }
  
  captureResourceBaseline() {
    return {
      timestamp: Date.now(),
      memory: process.memoryUsage(),
      sockets: this.getSocketStats(),
      heap_objects: this.estimateHeapObjects()
    };
  }
  
  getSocketStats() {
    return {
      active_connections: this.connectionPool.getActiveConnections(),
      idle_connections: this.connectionPool.getIdleConnections(),
      total_sockets: this.connectionPool.getTotalSockets(),
      sockets_per_host: this.connectionPool.getSocketsPerHost(),
      keep_alive_sockets: this.connectionPool.getKeepAliveStats(),
      pending_requests: this.connectionPool.getPendingRequests()
    };
  }
  
  sampleResources() {
    const sample = {
      timestamp: Date.now(),
      elapsed_minutes: (Date.now() - this.baseline.timestamp) / 60000,
      memory: process.memoryUsage(),
      sockets: this.getSocketStats(),
      heap_objects: this.estimateHeapObjects(),
      rpc_pool_stats: this.rpcPool.getStats()
    };
    
    // Calculate growth from baseline
    sample.growth = {
      rss_mb: Math.round((sample.memory.rss - this.baseline.memory.rss) / 1024 / 1024),
      heap_used_mb: Math.round((sample.memory.heapUsed - this.baseline.memory.heapUsed) / 1024 / 1024),
      socket_count: sample.sockets.total_sockets - this.baseline.sockets.total_sockets
    };
    
    // Calculate hourly growth rate
    sample.hourly_growth_rates = {
      rss_mb_per_hour: sample.growth.rss_mb / (sample.elapsed_minutes / 60),
      heap_mb_per_hour: sample.growth.heap_used_mb / (sample.elapsed_minutes / 60)
    };
    
    this.samples.push(sample);
    
    // Log warnings for resource issues
    this.checkResourceWarnings(sample);
    
    console.log('Resource sample:', {
      elapsed_min: sample.elapsed_minutes.toFixed(1),
      rss_growth_mb: sample.growth.rss_mb,
      rss_rate_mb_per_hour: sample.hourly_growth_rates.rss_mb_per_hour.toFixed(1),
      sockets: sample.sockets.total_sockets,
      pending: sample.sockets.pending_requests
    });
  }
  
  checkResourceWarnings(sample) {
    // Memory growth rate warning
    if (sample.hourly_growth_rates.rss_mb_per_hour > 12.5) {
      console.warn('High memory growth rate detected:', 
        sample.hourly_growth_rates.rss_mb_per_hour.toFixed(1), 'MB/hour');
    }
    
    // Socket explosion warning
    const maxSockets = Object.values(sample.sockets.sockets_per_host).reduce((sum, count) => sum + count, 0);
    const socketUtilization = sample.sockets.total_sockets / (maxSockets || 100);
    if (socketUtilization > 0.9) {
      console.warn('Socket pool near capacity:', (socketUtilization * 100).toFixed(1), '%');
    }
    
    // Pending requests backlog
    if (sample.sockets.pending_requests > 50) {
      console.warn('High pending request count:', sample.sockets.pending_requests);
    }
  }
}
```

### Step 4: Complete Per-Method Latency Trend Analysis
Track latency trends for each RPC method separately:
```javascript
class LatencyTrendAnalyzer {
  constructor() {
    this.methodLatencies = new Map();
    this.trendAnalysis = new Map();
  }
  
  recordLatency(method, latencyMs, addressType) {
    if (!this.methodLatencies.has(method)) {
      this.methodLatencies.set(method, []);
    }
    
    this.methodLatencies.get(method).push({
      timestamp: Date.now(),
      latency: latencyMs,
      addressType: addressType
    });
  }
  
  analyzeLatencyTrends() {
    const trends = {};
    
    for (const [method, latencies] of this.methodLatencies) {
      if (latencies.length < 10) {
        trends[method] = {
          status: 'insufficient_data',
          sample_count: latencies.length
        };
        continue;
      }
      
      const timeWindows = this.createTimeWindows(latencies, 300000); // 5-minute windows
      const trendSlope = this.calculateTrendSlope(timeWindows);
      const recentLatencies = latencies.slice(-Math.min(50, latencies.length));
      
      trends[method] = {
        sample_count: latencies.length,
        time_windows: timeWindows.length,
        p50_latency_ms: this.calculatePercentile(latencies.map(l => l.latency), 0.5),
        p95_latency_ms: this.calculatePercentile(latencies.map(l => l.latency), 0.95),
        p99_latency_ms: this.calculatePercentile(latencies.map(l => l.latency), 0.99),
        trend_slope_ms_per_hour: trendSlope.slope,
        trend_r_squared: trendSlope.rSquared,
        degrading: trendSlope.slope > 5, // >5ms/hour degradation
        significant_trend: trendSlope.rSquared > 0.7,
        recent_avg_latency: recentLatencies.reduce((sum, l) => sum + l.latency, 0) / recentLatencies.length,
        baseline_avg_latency: latencies.slice(0, Math.min(50, latencies.length))
          .reduce((sum, l) => sum + l.latency, 0) / Math.min(50, latencies.length)
      };
      
      // Calculate degradation percentage
      if (trends[method].baseline_avg_latency > 0) {
        trends[method].degradation_pct = ((trends[method].recent_avg_latency - trends[method].baseline_avg_latency) 
          / trends[method].baseline_avg_latency * 100).toFixed(1);
      }
    }
    
    return trends;
  }
  
  calculateTrendSlope(timeWindows) {
    if (timeWindows.length < 3) {
      return { slope: 0, rSquared: 0, insufficient_data: true };
    }
    
    // Convert timestamps to hours for more meaningful slope
    const points = timeWindows.map(w => ({
      x: (w.window_center - timeWindows[0].window_center) / 3600000, // hours
      y: w.avg_latency
    }));
    
    // Linear regression calculation
    const n = points.length;
    const sumX = points.reduce((sum, p) => sum + p.x, 0);
    const sumY = points.reduce((sum, p) => sum + p.y, 0);
    const sumXY = points.reduce((sum, p) => sum + (p.x * p.y), 0);
    const sumXX = points.reduce((sum, p) => sum + (p.x * p.x), 0);
    const sumYY = points.reduce((sum, p) => sum + (p.y * p.y), 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    
    // Calculate R-squared
    const meanY = sumY / n;
    const ssTotal = points.reduce((sum, p) => sum + Math.pow(p.y - meanY, 2), 0);
    const ssResidual = points.reduce((sum, p) => {
      const predicted = slope * p.x + (sumY - slope * sumX) / n;
      return sum + Math.pow(p.y - predicted, 2);
    }, 0);
    
    const rSquared = ssTotal > 0 ? 1 - (ssResidual / ssTotal) : 0;
    
    return {
      slope: isNaN(slope) ? 0 : slope,
      rSquared: isNaN(rSquared) ? 0 : Math.max(0, rSquared),
      sample_windows: n
    };
  }
}
```

### Step 5: Complete 4-Hour Stability Test
Run comprehensive stability test with proper validation:
```javascript
async run4HourStabilityTest() {
  const testDurationMs = 4 * 60 * 60 * 1000; // 4 hours
  const testStartTime = Date.now();
  
  console.log('Starting 4-hour hot address stability test...');
  
  // Initialize components
  const resourceMonitor = new ResourceMonitorCorrected(this.rpcPool, this.connectionPool);
  const latencyAnalyzer = new LatencyTrendAnalyzer();
  const sampler = new HotAddressSamplerCorrected(this.hotAddresses, this.rpcPool);
  
  // Start monitoring
  resourceMonitor.startContinuousMonitoring();
  
  // Test statistics
  const testStats = {
    requests_attempted: 0,
    requests_successful: 0,
    requests_failed: 0,
    method_usage: new Map(),
    circuit_breaker_trips: 0
  };
  
  // Main test loop - consistent load
  while (Date.now() - testStartTime < testDurationMs) {
    const cycleStartTime = Date.now();
    
    try {
      // Select random hot address
      const addressCategory = this.selectRandomAddressCategory();
      const address = this.selectRandomAddressFromCategory(addressCategory);
      const method = sampler.getNextMethodForAddress(address.address, addressCategory);
      
      if (!method) {
        // All methods rate limited, wait
        await new Promise(resolve => setTimeout(resolve, 1000));
        continue;
      }
      
      testStats.requests_attempted++;
      const methodUsage = testStats.method_usage.get(method.name) || 0;
      testStats.method_usage.set(method.name, methodUsage + 1);
      
      // Make RPC call and measure latency
      const rpcStartTime = Date.now();
      
      try {
        const params = method.params(address.address);
        await this.rpcPool.call(method.name, params);
        
        const latency = Date.now() - rpcStartTime;
        latencyAnalyzer.recordLatency(method.name, latency, addressCategory);
        testStats.requests_successful++;
        
      } catch (rpcError) {
        const latency = Date.now() - rpcStartTime;
        latencyAnalyzer.recordLatency(method.name, latency, addressCategory);
        testStats.requests_failed++;
        
        if (rpcError.message.includes('circuit')) {
          testStats.circuit_breaker_trips++;
        }
        
        console.log(`RPC error for ${method.name}:`, rpcError.message);
      }
      
    } catch (error) {
      console.error('Test loop error:', error.message);
      testStats.requests_failed++;
    }
    
    // Maintain consistent request rate (~1 request per 5 seconds)
    const cycleTime = Date.now() - cycleStartTime;
    const targetCycleTime = 5000;
    if (cycleTime < targetCycleTime) {
      await new Promise(resolve => setTimeout(resolve, targetCycleTime - cycleTime));
    }
  }
  
  // Stop monitoring and analyze results
  resourceMonitor.stopMonitoring();
  
  console.log('4-hour test completed, generating analysis...');
  return this.generateStabilityReport(testStats, resourceMonitor, latencyAnalyzer);
}
```

### Step 6: Final Validation Report
Generate comprehensive report with pass/fail gates:
```javascript
generateStabilityReport(testStats, resourceMonitor, latencyAnalyzer) {
  const finalSample = resourceMonitor.samples[resourceMonitor.samples.length - 1];
  const stabilityReport = latencyAnalyzer.getMethodStabilityReport();
  
  // Memory stability analysis
  const memoryStable = finalSample.hourly_growth_rates.rss_mb_per_hour <= 12.5;
  const maxMemoryGrowth = Math.max(...resourceMonitor.samples.map(s => s.growth.rss_mb));
  
  // Success rate analysis
  const successRate = testStats.requests_successful / testStats.requests_attempted;
  
  const report = {
    test_summary: {
      duration_hours: 4,
      start_time: new Date(Date.now() - 4 * 60 * 60 * 1000).toISOString(),
      end_time: new Date().toISOString(),
      requests_attempted: testStats.requests_attempted,
      requests_successful: testStats.requests_successful,
      overall_success_rate_pct: Math.round(successRate * 100)
    },
    memory_analysis: {
      final_growth_mb: finalSample.growth.rss_mb,
      hourly_growth_rate_mb: finalSample.hourly_growth_rates.rss_mb_per_hour.toFixed(2),
      max_growth_during_test_mb: maxMemoryGrowth,
      memory_stable: memoryStable,
      baseline_rss_mb: Math.round(resourceMonitor.baseline.memory.rss / 1024 / 1024),
      final_rss_mb: Math.round(finalSample.memory.rss / 1024 / 1024)
    },
    latency_analysis: {
      methods_analyzed: stabilityReport.methods_analyzed,
      stable_methods: stabilityReport.stable_methods,
      degrading_methods: stabilityReport.degrading_methods,
      latency_stable: stabilityReport.overall_stability,
      detailed_trends: latencyAnalyzer.analyzeLatencyTrends()
    },
    pass_gates: {
      success_rate_above_95pct: successRate >= 0.95,
      memory_growth_under_50mb: maxMemoryGrowth <= 50,
      memory_rate_under_12_5mb_per_hour: finalSample.hourly_growth_rates.rss_mb_per_hour <= 12.5,
      no_significant_latency_degradation: stabilityReport.overall_stability,
      circuit_breaker_trips_acceptable: (testStats.circuit_breaker_trips / 4) <= 10,
      socket_growth_controlled: Math.abs(finalSample.growth.socket_count) <= 20
    }
  };
  
  report.overall_pass = Object.values(report.pass_gates).every(gate => gate === true);
  
  return report;
}
```

## CLEAR SUCCESS CRITERIA
- **Memory Stability**: RSS growth ≤50MB total AND ≤12.5MB/hour sustained rate
- **Performance Stability**: No significant latency degradation (>5ms/hour with R² > 0.7)
- **Success Rate**: ≥95% of RPC requests successful over 4 hours
- **Circuit Breaker**: ≤10 trips per hour with successful recovery
- **Socket Stability**: Socket count growth ≤±20 connections from baseline

## REQUIREMENTS-BASED VALIDATION
- **Memory Efficiency**: Hourly growth rate monitoring prevents long-term memory leaks
- **Latency Trends**: Per-method trend analysis with statistical significance
- **Resource Monitoring**: Socket pool and connection management validation
- **Method Coverage**: All RPC methods tested with appropriate rate limiting
- **Long-term Stability**: 4-hour sustained load proves 24/7 operation capability
- **Comprehensive Reporting**: Actionable recommendations based on test results