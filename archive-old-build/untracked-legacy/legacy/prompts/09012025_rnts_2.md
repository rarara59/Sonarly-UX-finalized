# PROMPT RN2-CORRECTED: Time-Window Slot Scanning Test

## SINGLE FOCUS
Validate RPC pool performance using proper time-window pagination with baseline-relative performance gates

## EXPLICIT FILE PATHS
- **CREATE**: `scripts/test-time-window-scan-corrected.js`
- **CREATE**: `scripts/time-window-scanner.js`
- **CREATE**: `results/time-scan-baseline.json` (baseline output)
- **CREATE**: `results/time-scan-results.json` (test output)
- **IMPORT**: RPC pool components from refactored system

## INCREMENTAL IMPLEMENTATION

### Step 1: Time-Window Scanner Implementation
Replace slot loops with proper signature pagination:
```javascript
class TimeWindowScanner {
  constructor(rpcPool) {
    this.rpcPool = rpcPool;
    this.metrics = {
      getSignaturesForAddress: [],
      getTransaction: [],
      errors: new Map()
    };
  }
  
  async scanTimeWindow(programId, startTime, endTime) {
    let cursor = null;
    const allTransactions = [];
    let totalSignatures = 0;
    
    while (true) {
      const sigStartTime = Date.now();
      
      try {
        const signatures = await this.rpcPool.call('getSignaturesForAddress', [
          programId,
          {
            limit: 1000,
            before: cursor,
            until: null
          }
        ]);
        
        const sigLatency = Date.now() - sigStartTime;
        this.metrics.getSignaturesForAddress.push(sigLatency);
        
        if (signatures.length === 0) break;
        
        // Filter by time window
        const filteredSigs = signatures.filter(sig => 
          sig.blockTime >= startTime && sig.blockTime <= endTime
        );
        
        // Process transactions with proper versioning
        for (const sig of filteredSigs) {
          const txResult = await this.getTransactionWithMetrics(sig.signature);
          if (txResult.transaction) {
            allTransactions.push(txResult.transaction);
          }
        }
        
        totalSignatures += signatures.length;
        
        // Check if we've passed the time window
        const lastBlockTime = signatures[signatures.length - 1].blockTime;
        if (lastBlockTime < startTime) break;
        
        // Update cursor for next page
        cursor = signatures[signatures.length - 1].signature;
        
      } catch (error) {
        this.recordError('getSignaturesForAddress', error);
        break;
      }
    }
    
    return { transactions: allTransactions, totalSignatures };
  }
  
  async getTransactionWithMetrics(signature) {
    const startTime = Date.now();
    
    try {
      const transaction = await this.rpcPool.call('getTransaction', [
        signature,
        {
          maxSupportedTransactionVersion: 0,
          encoding: 'json'
        }
      ]);
      
      const latency = Date.now() - startTime;
      this.metrics.getTransaction.push(latency);
      
      return { transaction, latency, success: true };
      
    } catch (error) {
      const latency = Date.now() - startTime;
      this.recordError('getTransaction', error);
      
      return { transaction: null, latency, success: false, error };
    }
  }
}
```

### Step 2: Baseline Performance Measurement
Establish performance baseline before main test:
```javascript
async measurePerformanceBaseline() {
  console.log('Measuring performance baseline...');
  
  const baselineStartTime = Math.floor(Date.now() / 1000) - 7200; // 2 hours ago
  const baselineEndTime = Math.floor(Date.now() / 1000) - 3600;   // 1 hour ago
  
  const baselineResults = await this.scanner.scanTimeWindow(
    'RAYDIUM_AMM_V4',
    baselineStartTime,
    baselineEndTime
  );
  
  const baseline = {
    timestamp: new Date().toISOString(),
    duration_seconds: 3600,
    transactions_found: baselineResults.transactions.length,
    signatures_processed: baselineResults.totalSignatures,
    getSignaturesForAddress_latency: {
      p50: this.calculatePercentile(this.scanner.metrics.getSignaturesForAddress, 0.5),
      p95: this.calculatePercentile(this.scanner.metrics.getSignaturesForAddress, 0.95),
      p99: this.calculatePercentile(this.scanner.metrics.getSignaturesForAddress, 0.99)
    },
    getTransaction_latency: {
      p50: this.calculatePercentile(this.scanner.metrics.getTransaction, 0.5),
      p95: this.calculatePercentile(this.scanner.metrics.getTransaction, 0.95),
      p99: this.calculatePercentile(this.scanner.metrics.getTransaction, 0.99)
    },
    success_rate: this.calculateSuccessRate()
  };
  
  // Save baseline for comparison
  await this.saveBaseline(baseline);
  return baseline;
}
```

### Step 3: Error Categorization System
Properly categorize all RPC errors for analysis:
```javascript
recordError(method, error) {
  const errorKey = `${method}_${this.categorizeError(error)}`;
  const count = this.metrics.errors.get(errorKey) || 0;
  this.metrics.errors.set(errorKey, count + 1);
}

categorizeError(error) {
  const message = error.message?.toLowerCase() || '';
  
  if (message.includes('timeout') || error.code === 'TIMEOUT') return 'TIMEOUT';
  if (message.includes('connection reset') || error.code === 'ECONNRESET') return 'CONN_RESET';
  if (message.includes('rate limit') || error.code === 429) return 'RATE_LIMIT';
  if (error.code >= 500) return 'SERVER_5XX';
  if (error.code >= 400 && error.code < 500) return 'CLIENT_4XX';
  if (message.includes('json') || message.includes('parse')) return 'INVALID_JSON';
  if (message.includes('circuit') || message.includes('breaker')) return 'CB_OPEN';
  
  return 'UNKNOWN';
}
```

### Step 4: Baseline-Relative Performance Gates
Compare performance against measured baseline rather than absolute values:
```javascript
async validatePerformanceAgainstBaseline(testResults, baseline) {
  const testLatency = {
    getSignaturesForAddress_p95: this.calculatePercentile(this.scanner.metrics.getSignaturesForAddress, 0.95),
    getTransaction_p95: this.calculatePercentile(this.scanner.metrics.getTransaction, 0.95)
  };
  
  const performanceGates = {
    success_rate: testResults.success_rate >= 0.99,
    getSignaturesForAddress_p95_relative: testLatency.getSignaturesForAddress_p95 <= baseline.getSignaturesForAddress_latency.p95 * 1.2,
    getTransaction_p95_relative: testLatency.getTransaction_p95 <= baseline.getTransaction_latency.p95 * 1.2,
    error_rate: testResults.error_rate <= 0.01,
    circuit_breaker_stable: this.getCircuitBreakerTrips() < 10
  };
  
  const allPassed = Object.values(performanceGates).every(gate => gate === true);
  
  return {
    gates: performanceGates,
    all_passed: allPassed,
    baseline_comparison: {
      p95_improvement_pct: ((baseline.getTransaction_latency.p95 - testLatency.getTransaction_p95) / baseline.getTransaction_latency.p95 * 100).toFixed(1)
    }
  };
}
```

### Step 5: Comprehensive Metrics Collection
Track separate metrics for each RPC method:
```javascript
generateComprehensiveResults() {
  const results = {
    test_summary: {
      start_time: this.testStartTime.toISOString(),
      duration_minutes: (Date.now() - this.testStartTime) / 60000,
      transactions_processed: this.processedTransactions,
      total_requests: this.metrics.getSignaturesForAddress.length + this.metrics.getTransaction.length
    },
    performance_by_method: {
      getSignaturesForAddress: {
        requests: this.metrics.getSignaturesForAddress.length,
        latency_ms: {
          p50: this.calculatePercentile(this.metrics.getSignaturesForAddress, 0.5),
          p95: this.calculatePercentile(this.metrics.getSignaturesForAddress, 0.95),
          p99: this.calculatePercentile(this.metrics.getSignaturesForAddress, 0.99),
          max: Math.max(...this.metrics.getSignaturesForAddress)
        }
      },
      getTransaction: {
        requests: this.metrics.getTransaction.length,
        latency_ms: {
          p50: this.calculatePercentile(this.metrics.getTransaction, 0.5),
          p95: this.calculatePercentile(this.metrics.getTransaction, 0.95),
          p99: this.calculatePercentile(this.metrics.getTransaction, 0.99),
          max: Math.max(...this.metrics.getTransaction)
        }
      }
    },
    errors_by_category: Object.fromEntries(this.metrics.errors)
  };
  
  return results;
}
```

### Step 6: Circuit Breaker Integration Testing
Monitor circuit breaker behavior during sustained scanning:
```javascript
monitorCircuitBreakerDuringTest() {
  const monitor = {
    transitions: [],
    tripCount: 0,
    recoveryTimes: []
  };
  
  this.circuitBreaker.on('stateChange', (from, to, endpoint) => {
    monitor.transitions.push({
      timestamp: Date.now(),
      from,
      to,
      endpoint,
      reason: this.circuitBreaker.getLastError()?.message
    });
    
    if (to === 'OPEN') monitor.tripCount++;
  });
  
  return monitor;
}
```

## CLEAR SUCCESS CRITERIA
- Success rate ≥99% for all RPC calls
- P95 latency ≤baseline × 1.2 for both getSignaturesForAddress and getTransaction
- Error rate <1% with proper error categorization
- Circuit breaker transitions <10 during scan

## REQUIREMENTS-BASED VALIDATION
- **Success Rate**: ≥99% of all RPC requests successful
- **Relative Performance**: P95 latency ≤120% of measured baseline
- **Error Handling**: All errors categorized, <1% total error rate
- **API Correctness**: Proper maxSupportedTransactionVersion usage
- **Circuit Breaker**: <10 trips with successful recovery
- **Memory Efficiency**: <200MB total memory during scan