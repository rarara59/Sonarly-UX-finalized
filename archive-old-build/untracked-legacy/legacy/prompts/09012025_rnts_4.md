# PROMPT RN4-CORRECTED: Devnet Confirmation Test

## SINGLE FOCUS
Validate transaction execution pipeline using Devnet with proper blockhash TTL, simulation, and confirmation handling

## EXPLICIT FILE PATHS
- **CREATE**: `scripts/test-devnet-confirmation-corrected.js`
- **CREATE**: `scripts/devnet-transaction-builder.js`
- **CREATE**: `scripts/confirmation-tracker.js`
- **CREATE**: `results/devnet-confirmation-results.json` (output)
- **IMPORT**: Transaction execution components from refactored system

## INCREMENTAL IMPLEMENTATION

### Step 1: Devnet Transaction Builder with Proper Versioning
Create transaction builder that handles VersionedTransactions correctly:
```javascript
import { 
  VersionedTransaction, 
  TransactionMessage,
  SystemProgram,
  PublicKey,
  Keypair
} from '@solana/web3.js';

class DevnetTransactionBuilder {
  constructor(devnetConnection) {
    this.connection = devnetConnection;
    this.testKeypair = Keypair.generate(); // Test keypair for devnet
  }
  
  async buildTestTransaction(recipient, lamports) {
    try {
      // Get fresh blockhash with proper commitment
      const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash('confirmed');
      
      // Create instruction
      const instruction = SystemProgram.transfer({
        fromPubkey: this.testKeypair.publicKey,
        toPubkey: new PublicKey(recipient),
        lamports: lamports
      });
      
      // Build VersionedTransaction
      const messageV0 = new TransactionMessage({
        payerKey: this.testKeypair.publicKey,
        recentBlockhash: blockhash,
        instructions: [instruction]
      }).compileToV0Message();
      
      const transaction = new VersionedTransaction(messageV0);
      
      return {
        transaction,
        blockhash,
        lastValidBlockHeight,
        payer: this.testKeypair.publicKey
      };
      
    } catch (error) {
      console.error('Failed to build test transaction:', error);
      throw error;
    }
  }
  
  async airdropIfNeeded() {
    const balance = await this.connection.getBalance(this.testKeypair.publicKey);
    if (balance < 1000000) { // Less than 0.001 SOL
      console.log('Requesting devnet airdrop...');
      const signature = await this.connection.requestAirdrop(
        this.testKeypair.publicKey,
        1000000000 // 1 SOL
      );
      await this.connection.confirmTransaction(signature);
      console.log('Airdrop confirmed');
    }
  }
}
```

### Step 2: Simulation with Proper Encoding and Error Detection
Implement transaction simulation with correct parameters:
```javascript
class TransactionSimulator {
  constructor(connection) {
    this.connection = connection;
  }
  
  async simulateTransaction(transactionBuilder, testTx) {
    const startTime = Date.now();
    
    try {
      // Serialize transaction for simulation
      const serialized = testTx.transaction.serialize();
      
      // Simulate with proper options
      const simulation = await this.connection.simulateTransaction(
        testTx.transaction,
        {
          commitment: 'processed',
          sigVerify: false, // Skip signature verification for simulation
          replaceRecentBlockhash: false,
          accounts: {
            encoding: 'base64',
            addresses: [testTx.payer.toString()]
          }
        }
      );
      
      const latency = Date.now() - startTime;
      
      // Analyze simulation results
      const result = {
        success: !simulation.value.err,
        latency_ms: latency,
        logs: simulation.value.logs || [],
        units_consumed: simulation.value.unitsConsumed || 0,
        error: simulation.value.err,
        accounts: simulation.value.accounts || []
      };
      
      if (result.error) {
        console.log('Simulation failed:', result.error);
        result.error_type = this.categorizeSimulationError(result.error);
      }
      
      return result;
      
    } catch (error) {
      return {
        success: false,
        latency_ms: Date.now() - startTime,
        error: error.message,
        error_type: 'SIMULATION_CALL_FAILED'
      };
    }
  }
  
  categorizeSimulationError(error) {
    if (!error) return null;
    
    const errorStr = JSON.stringify(error).toLowerCase();
    
    if (errorStr.includes('blockhash')) return 'BLOCKHASH_EXPIRED';
    if (errorStr.includes('insufficient')) return 'INSUFFICIENT_FUNDS';
    if (errorStr.includes('account')) return 'ACCOUNT_ERROR';
    if (errorStr.includes('instruction')) return 'INSTRUCTION_ERROR';
    
    return 'UNKNOWN_SIM_ERROR';
  }
}
```

### Step 3: Transaction Submission with Timeout Handling
Submit transactions with proper commitment levels and timeout management:
```javascript
class DevnetTransactionSubmitter {
  constructor(connection, testKeypair) {
    this.connection = connection;
    this.testKeypair = testKeypair;
    this.submissionStats = {
      attempted: 0,
      successful: 0,
      failed: 0,
      timeouts: 0
    };
  }
  
  async submitAndConfirm(transactionData, timeoutMs = 30000) {
    this.submissionStats.attempted++;
    const startTime = Date.now();
    
    try {
      // Sign transaction
      transactionData.transaction.sign([this.testKeypair]);
      
      // Submit transaction
      const signature = await this.connection.sendTransaction(
        transactionData.transaction,
        {
          skipPreflight: false,
          preflightCommitment: 'processed',
          maxRetries: 3
        }
      );
      
      console.log('Transaction submitted:', signature);
      
      // Wait for confirmation with timeout
      const confirmationResult = await this.waitForConfirmationWithTimeout(
        signature,
        transactionData.lastValidBlockHeight,
        timeoutMs
      );
      
      const totalTime = Date.now() - startTime;
      
      if (confirmationResult.confirmed) {
        this.submissionStats.successful++;
        return {
          success: true,
          signature,
          confirmation_time_ms: confirmationResult.confirmationTime,
          total_time_ms: totalTime,
          commitment_level: confirmationResult.commitmentLevel,
          slot: confirmationResult.slot
        };
      } else {
        this.submissionStats.failed++;
        if (confirmationResult.timeout) {
          this.submissionStats.timeouts++;
        }
        return {
          success: false,
          signature,
          total_time_ms: totalTime,
          timeout: confirmationResult.timeout,
          error: confirmationResult.error
        };
      }
      
    } catch (error) {
      this.submissionStats.failed++;
      return {
        success: false,
        total_time_ms: Date.now() - startTime,
        error: error.message,
        error_type: this.categorizeSubmissionError(error)
      };
    }
  }
  
  async waitForConfirmationWithTimeout(signature, lastValidBlockHeight, timeoutMs) {
    const startTime = Date.now();
    
    return new Promise(async (resolve) => {
      const timeout = setTimeout(() => {
        resolve({
          confirmed: false,
          timeout: true,
          confirmationTime: Date.now() - startTime
        });
      }, timeoutMs);
      
      try {
        const confirmation = await this.connection.confirmTransaction({
          signature,
          lastValidBlockHeight,
          commitment: 'confirmed'
        });
        
        clearTimeout(timeout);
        
        resolve({
          confirmed: !confirmation.value.err,
          timeout: false,
          confirmationTime: Date.now() - startTime,
          commitmentLevel: 'confirmed',
          error: confirmation.value.err,
          slot: confirmation.context.slot
        });
        
      } catch (error) {
        clearTimeout(timeout);
        resolve({
          confirmed: false,
          timeout: false,
          confirmationTime: Date.now() - startTime,
          error: error.message
        });
      }
    });
  }
  
  categorizeSubmissionError(error) {
    const message = error.message?.toLowerCase() || '';
    
    if (message.includes('blockhash not found')) return 'EXPIRED_BLOCKHASH';
    if (message.includes('insufficient')) return 'INSUFFICIENT_FUNDS';
    if (message.includes('timeout')) return 'NETWORK_TIMEOUT';
    if (message.includes('rate limit')) return 'RATE_LIMITED';
    
    return 'UNKNOWN_SUBMISSION_ERROR';
  }
}
```

### Step 4: Blockhash TTL Testing
Test blockhash expiration and recovery handling:
```javascript
class BlockhashTTLTester {
  constructor(connection, txBuilder, submitter) {
    this.connection = connection;
    this.txBuilder = txBuilder;
    this.submitter = submitter;
  }
  
  async testExpiredBlockhashHandling() {
    console.log('Testing expired blockhash handling...');
    
    // Build transaction with current blockhash
    const recipient = Keypair.generate().publicKey;
    const testTx = await this.txBuilder.buildTestTransaction(recipient, 100000);
    
    console.log('Waiting for blockhash to expire (150+ slots)...');
    
    // Wait for blockhash to expire (approximately 60-90 seconds)
    const initialSlot = await this.connection.getSlot();
    let currentSlot = initialSlot;
    
    while (currentSlot - initialSlot < 151) { // 150+ slots for expiration
      await new Promise(resolve => setTimeout(resolve, 1000));
      currentSlot = await this.connection.getSlot();
      
      if ((currentSlot - initialSlot) % 30 === 0) {
        console.log(`Waiting... ${currentSlot - initialSlot}/151 slots elapsed`);
      }
    }
    
    console.log('Blockhash should now be expired, attempting submission...');
    
    // Try to submit expired transaction
    const expiredResult = await this.submitter.submitAndConfirm(testTx, 15000);
    
    // Verify expected failure
    const expectedExpiredFailure = !expiredResult.success && 
      (expiredResult.error_type === 'EXPIRED_BLOCKHASH' || 
       expiredResult.error?.includes('blockhash'));
    
    // Build new transaction with fresh blockhash
    console.log('Building transaction with fresh blockhash...');
    const freshTx = await this.txBuilder.buildTestTransaction(recipient, 100000);
    const freshResult = await this.submitter.submitAndConfirm(freshTx);
    
    return {
      expired_transaction: {
        slots_waited: currentSlot - initialSlot,
        submission_result: expiredResult,
        properly_failed: expectedExpiredFailure
      },
      fresh_transaction: {
        submission_result: freshResult,
        succeeded: freshResult.success
      },
      blockhash_ttl_handling_correct: expectedExpiredFailure && freshResult.success
    };
  }
}
```

### Step 5: Confirmation Timeout Testing
Test confirmation behavior under various timeout scenarios:
```javascript
async testConfirmationTimeouts() {
  console.log('Testing confirmation timeouts...');
  
  const results = {
    short_timeout_test: null,
    normal_timeout_test: null,
    long_timeout_test: null
  };
  
  // Test 1: Short timeout (5 seconds) - should timeout
  try {
    const recipient = Keypair.generate().publicKey;
    const testTx = await this.txBuilder.buildTestTransaction(recipient, 50000);
    
    const shortResult = await this.submitter.submitAndConfirm(testTx, 5000);
    results.short_timeout_test = {
      ...shortResult,
      expected_timeout: true,
      timeout_respected: shortResult.total_time_ms <= 6000 // 1s buffer
    };
  } catch (error) {
    results.short_timeout_test = { error: error.message };
  }
  
  // Test 2: Normal timeout (30 seconds) - should succeed
  try {
    const recipient = Keypair.generate().publicKey;
    const testTx = await this.txBuilder.buildTestTransaction(recipient, 75000);
    
    const normalResult = await this.submitter.submitAndConfirm(testTx, 30000);
    results.normal_timeout_test = {
      ...normalResult,
      expected_success: true,
      succeeded: normalResult.success
    };
  } catch (error) {
    results.normal_timeout_test = { error: error.message };
  }
  
  // Test 3: Long timeout (60 seconds) - should succeed quickly
  try {
    const recipient = Keypair.generate().publicKey;
    const testTx = await this.txBuilder.buildTestTransaction(recipient, 25000);
    
    const longResult = await this.submitter.submitAndConfirm(testTx, 60000);
    results.long_timeout_test = {
      ...longResult,
      expected_success: true,
      succeeded: longResult.success,
      quick_confirmation: longResult.confirmation_time_ms <= 10000
    };
  } catch (error) {
    results.long_timeout_test = { error: error.message };
  }
  
  return results;
}
```

### Step 6: Complete Devnet Validation Test
Run comprehensive devnet test with all components:
```javascript
class DevnetConfirmationTestCorrected {
  constructor(devnetEndpoint = 'https://api.devnet.solana.com') {
    this.connection = new Connection(devnetEndpoint, 'confirmed');
    this.txBuilder = new DevnetTransactionBuilder(this.connection);
    this.simulator = new TransactionSimulator(this.connection);
    this.submitter = new DevnetTransactionSubmitter(this.connection, this.txBuilder.testKeypair);
    this.ttlTester = new BlockhashTTLTester(this.connection, this.txBuilder, this.submitter);
  }
  
  async executeCompleteTest() {
    console.log('=== Devnet Confirmation Test - Complete Validation ===');
    
    try {
      // Setup: Ensure test account has SOL
      await this.txBuilder.airdropIfNeeded();
      
      // Test 1: Basic simulation and confirmation
      const basicTest = await this.runBasicSimulationTest();
      
      // Test 2: Blockhash TTL handling
      const ttlTest = await this.ttlTester.testExpiredBlockhashHandling();
      
      // Test 3: Confirmation timeout behavior
      const timeoutTest = await this.testConfirmationTimeouts();
      
      // Generate final report
      const report = this.generateComprehensiveReport({
        basic_simulation: basicTest,
        blockhash_ttl: ttlTest,
        confirmation_timeouts: timeoutTest,
        submission_stats: this.submitter.submissionStats
      });
      
      console.log('=== Devnet Test Complete ===');
      console.log('Overall Result:', report.overall_pass ? 'PASS' : 'FAIL');
      
      return report;
      
    } catch (error) {
      return {
        test_status: 'FAILED',
        error: error.message,
        overall_pass: false
      };
    }
  }
  
  async runBasicSimulationTest() {
    const recipient = Keypair.generate().publicKey;
    const testTx = await this.txBuilder.buildTestTransaction(recipient, 100000);
    
    // Simulate first
    const simulation = await this.simulator.simulateTransaction(this.txBuilder, testTx);
    
    // Submit if simulation passes
    let submission = null;
    if (simulation.success) {
      submission = await this.submitter.submitAndConfirm(testTx);
    }
    
    return {
      simulation_result: simulation,
      submission_result: submission,
      simulation_passed: simulation.success,
      submission_passed: submission?.success || false
    };
  }
  
  generateComprehensiveReport(testResults) {
    const report = {
      test_summary: {
        test_type: 'devnet_confirmation',
        completion_time: new Date().toISOString(),
        devnet_endpoint: this.connection.rpcEndpoint
      },
      simulation_analysis: {
        basic_simulation_passed: testResults.basic_simulation.simulation_passed,
        simulation_latency_ms: testResults.basic_simulation.simulation_result.latency_ms,
        proper_error_detection: testResults.basic_simulation.simulation_result.error_type !== 'SIMULATION_CALL_FAILED'
      },
      transaction_execution: {
        basic_submission_passed: testResults.basic_simulation.submission_passed,
        confirmation_latency_ms: testResults.basic_simulation.submission_result?.confirmation_time_ms,
        total_attempts: testResults.submission_stats.attempted,
        success_rate_pct: Math.round((testResults.submission_stats.successful / testResults.submission_stats.attempted) * 100)
      },
      blockhash_ttl_validation: {
        expired_properly_rejected: testResults.blockhash_ttl.expired_transaction.properly_failed,
        fresh_transaction_succeeded: testResults.blockhash_ttl.fresh_transaction.succeeded,
        ttl_handling_correct: testResults.blockhash_ttl.blockhash_ttl_handling_correct
      },
      timeout_validation: {
        short_timeout_respected: testResults.confirmation_timeouts.short_timeout_test?.timeout_respected || false,
        normal_timeout_succeeded: testResults.confirmation_timeouts.normal_timeout_test?.succeeded || false,
        long_timeout_quick: testResults.confirmation_timeouts.long_timeout_test?.quick_confirmation || false
      },
      pass_gates: {
        simulation_working: testResults.basic_simulation.simulation_passed,
        confirmation_working: testResults.basic_simulation.submission_passed,
        success_rate_above_95pct: (testResults.submission_stats.successful / testResults.submission_stats.attempted) >= 0.95,
        blockhash_ttl_handled: testResults.blockhash_ttl.blockhash_ttl_handling_correct,
        timeouts_respected: testResults.confirmation_timeouts.short_timeout_test?.timeout_respected || false
      }
    };
    
    report.overall_pass = Object.values(report.pass_gates).every(gate => gate === true);
    
    return report;
  }
}
```

## CLEAR SUCCESS CRITERIA
- Simulation detects invalid transactions before submission
- >95% of test transactions confirmed within 30 seconds
- Expired blockhash transactions properly rejected
- Fresh blockhash transactions succeed after expired ones fail
- Confirmation timeouts respected (no hanging processes)

## REQUIREMENTS-BASED VALIDATION
- **Simulation Accuracy**: PreFlight validation catches errors before network submission
- **Blockhash TTL**: Expired blockhashes rejected, fresh ones accepted
- **Timeout Handling**: Confirmation waits respect specified timeouts
- **Commitment Levels**: Proper use of processed/confirmed commitment
- **Error Classification**: Transaction failures properly categorized
- **Zero-Risk Testing**: All validation on Devnet, no mainnet risk