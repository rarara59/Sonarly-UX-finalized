# PROMPT RN5-CORRECTED: HTTP Adapter Chaos Engineering Test

## SINGLE FOCUS
Validate circuit breaker and failover using HTTP adapter-level chaos injection with traffic distribution logging

## EXPLICIT FILE PATHS
- **CREATE**: `scripts/test-chaos-engineering-corrected.js`
- **CREATE**: `scripts/http-chaos-adapter.js`
- **CREATE**: `scripts/traffic-distribution-monitor.js`
- **CREATE**: `results/chaos-engineering-results.json` (output)
- **IMPORT**: Complete RPC pool with circuit breaker

## INCREMENTAL IMPLEMENTATION

### Step 1: HTTP Adapter Chaos Injection
Create chaos adapter at HTTP request level:
```

### Step 4: Circuit Breaker State Monitoring
Monitor circuit breaker transitions during chaos:
```javascript
class CircuitBreakerChaosMonitor {
  constructor(circuitBreaker) {
    this.circuitBreaker = circuitBreaker;
    this.transitions = [];
    this.tripCounts = new Map();
    this.recoveryTimes = [];
    this.monitoring = false;
  }
  
  startMonitoring() {
    this.monitoring = true;
    this.resetStats();
    
    this.circuitBreaker.on('stateChange', (from, to, endpoint) => {
      const transition = {
        timestamp: Date.now(),
        endpoint,
        from,
        to,
        reason: this.circuitBreaker.getLastError(endpoint)?.message
      };
      
      this.transitions.push(transition);
      
      if (to === 'OPEN') {
        this.tripCounts.set(endpoint, (this.tripCounts.get(endpoint) || 0) + 1);
        console.log(`Circuit breaker OPENED for ${endpoint}:`, transition.reason);
      } else if (from === 'HALF_OPEN' && to === 'CLOSED') {
        this.recordRecovery(endpoint, transition.timestamp);
        console.log(`Circuit breaker RECOVERED for ${endpoint}`);
      } else if (from === 'HALF_OPEN' && to === 'OPEN') {
        console.log(`Circuit breaker recovery FAILED for ${endpoint}`);
      }
    });
    
    console.log('Circuit breaker monitoring started');
  }
  
  recordRecovery(endpoint, timestamp) {
    // Find the last OPEN transition for this endpoint
    const lastOpen = [...this.transitions]
      .reverse()
      .find(t => t.endpoint === endpoint && t.to === 'OPEN');
    
    if (lastOpen) {
      const recoveryTime = timestamp - lastOpen.timestamp;
      this.recoveryTimes.push({
        endpoint,
        recoveryTimeMs: recoveryTime,
        openTimestamp: lastOpen.timestamp,
        closedTimestamp: timestamp
      });
    }
  }
  
  getRecoveryAnalysis() {
    if (this.recoveryTimes.length === 0) return null;
    
    const recoveryTimesMs = this.recoveryTimes.map(r => r.recoveryTimeMs);
    
    return {
      recoveries_total: this.recoveryTimes.length,
      avg_recovery_time_ms: recoveryTimesMs.reduce((a, b) => a + b, 0) / recoveryTimesMs.length,
      min_recovery_time_ms: Math.min(...recoveryTimesMs),
      max_recovery_time_ms: Math.max(...recoveryTimesMs),
      successful_recoveries: this.recoveryTimes.length,
      recovery_details: this.recoveryTimes
    };
  }
}
```

### Step 5: Automatic Recovery Validation
Test system recovery when chaos stops:
```javascript
async validateAutomaticRecovery(targetEndpoint) {
  console.log('Validating automatic recovery...');
  
  const recoveryStartTime = Date.now();
  
  // Wait for circuit breaker to open on target endpoint
  await this.waitForCircuitBreakerState(targetEndpoint, 'OPEN', 30000);
  console.log(`Circuit breaker opened for ${targetEndpoint}`);
  
  // Disable chaos
  this.chaosAdapter.disableChaos();
  console.log('Chaos disabled - monitoring recovery...');
  
  // Wait for half-open state
  const halfOpenTime = await this.waitForCircuitBreakerState(targetEndpoint, 'HALF_OPEN', 60000);
  if (!halfOpenTime) {
    throw new Error('Circuit breaker did not enter HALF_OPEN state within timeout');
  }
  
  // Wait for closed state (successful recovery)
  const closedTime = await this.waitForCircuitBreakerState(targetEndpoint, 'CLOSED', 60000);
  if (!closedTime) {
    throw new Error('Circuit breaker did not recover to CLOSED state within timeout');
  }
  
  const totalRecoveryTime = closedTime - recoveryStartTime;
  
  // Validate probe success
  const probeStats = this.circuitBreaker.getProbeStats(targetEndpoint);
  
  return {
    recovery_successful: true,
    total_recovery_time_ms: totalRecoveryTime,
    half_open_delay_ms: halfOpenTime - recoveryStartTime,
    probe_success_count: probeStats.successCount,
    probe_failure_count: probeStats.failureCount,
    final_state: this.circuitBreaker.getState(targetEndpoint)
  };
}

async waitForCircuitBreakerState(endpoint, targetState, timeoutMs) {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    
    const checkState = () => {
      const currentState = this.circuitBreaker.getState(endpoint);
      
      if (currentState === targetState) {
        resolve(Date.now());
        return;
      }
      
      if (Date.now() - startTime > timeoutMs) {
        resolve(null); // Timeout
        return;
      }
      
      setTimeout(checkState, 1000); // Check every second
    };
    
    checkState();
  });
}
```

### Step 6: Overall System Impact Analysis
Measure system-wide impact during single endpoint chaos:
```javascript
analyzeSystemImpact(chaosResults) {
  const systemAnalysis = {
    chaos_effectiveness: {
      target_endpoint_failure_rate: this.calculateEndpointFailureRate(chaosResults.chaos_stats),
      chaos_requests_intercepted: chaosResults.chaos_stats.requestsIntercepted,
      faults_injected: chaosResults.chaos_stats.faultsInjected
    },
    system_resilience: {
      overall_success_rate: chaosResults.chaos_period.success_rate,
      traffic_shedding_effective: this.verifyTrafficShedding(chaosResults.traffic_analysis),
      circuit_breaker_protection: chaosResults.chaos_period.circuit_breaker_trips > 0,
      recovery_time_ms: chaosResults.recovery_period.total_recovery_time_ms
    },
    pass_gates: {
      chaos_injection_working: chaosResults.chaos_stats.faultsInjected > 0,
      overall_success_above_97pct: chaosResults.chaos_period.success_rate >= 0.97,
      traffic_shifted_away: this.verifyTrafficShedding(chaosResults.traffic_analysis),
      recovery_under_60s: chaosResults.recovery_period.total_recovery_time_ms <= 60000,
      circuit_breaker_opened: chaosResults.chaos_period.circuit_breaker_trips > 0
    }
  };
  
  systemAnalysis.all_gates_passed = Object.values(systemAnalysis.pass_gates)
    .every(gate => gate === true);
  
  return systemAnalysis;
}
```

## CLEAR SUCCESS CRITERIA
- Circuit breaker opens on target endpoint within expected failure threshold (6 failures)
- Overall system success rate ≥97% during single endpoint chaos
- Traffic sheds away from failed endpoint to healthy endpoints
- Automatic recovery occurs within 60 seconds after chaos stops
- Half-open probes succeed and circuit breaker closes

## REQUIREMENTS-BASED VALIDATION
- **Chaos Injection**: Faults successfully injected at HTTP adapter level
- **Failure Detection**: Circuit breaker opens within 6 failures on target endpoint
- **System Resilience**: ≥97% overall success with 30% failure rate on one endpoint
- **Traffic Shedding**: Measurable traffic shift away from failed endpoint
- **Recovery Speed**: Complete recovery within 60 seconds of chaos cessation
- **Probe Validation**: Half-open probes succeed when endpoint recoversjavascript
class HTTPChaosAdapter {
  constructor(baseAdapter, chaosConfig = {}) {
    this.baseAdapter = baseAdapter;
    this.chaosConfig = {
      enabled: false,
      targetEndpoints: [],
      failureRate: 0.3,
      faultTypes: ['TIMEOUT', 'ECONNRESET', 'SERVER_ERROR'],
      delayJitterMs: { min: 0, max: 5000 },
      ...chaosConfig
    };
    this.chaosStats = {
      requestsIntercepted: 0,
      faultsInjected: 0,
      faultsByType: new Map()
    };
  }
  
  async request(url, options) {
    this.chaosStats.requestsIntercepted++;
    
    // Check if chaos should be applied to this endpoint
    if (this.shouldInjectChaos(url)) {
      return await this.injectChaos(url, options);
    }
    
    // Normal request through base adapter
    return await this.baseAdapter.request(url, options);
  }
  
  shouldInjectChaos(url) {
    if (!this.chaosConfig.enabled) return false;
    
    const matchesTarget = this.chaosConfig.targetEndpoints.some(target => 
      url.includes(target)
    );
    
    if (!matchesTarget) return false;
    
    return Math.random() < this.chaosConfig.failureRate;
  }
  
  async injectChaos(url, options) {
    this.chaosStats.faultsInjected++;
    
    const faultType = this.selectRandomFaultType();
    this.chaosStats.faultsByType.set(faultType, 
      (this.chaosStats.faultsByType.get(faultType) || 0) + 1
    );
    
    console.log(`Injecting ${faultType} fault for ${url}`);
    
    switch (faultType) {
      case 'TIMEOUT':
        // Simulate timeout
        await new Promise(resolve => setTimeout(resolve, 30000));
        throw new Error('Request timeout (chaos injected)');
        
      case 'ECONNRESET':
        // Simulate connection reset
        const error = new Error('Connection reset (chaos injected)');
        error.code = 'ECONNRESET';
        throw error;
        
      case 'SERVER_ERROR':
        // Simulate server error
        throw new Error('Internal server error (chaos injected)');
        
      case 'DELAY':
        // Inject random delay then succeed
        const delay = Math.random() * (this.chaosConfig.delayJitterMs.max - this.chaosConfig.delayJitterMs.min) + this.chaosConfig.delayJitterMs.min;
        await new Promise(resolve => setTimeout(resolve, delay));
        return await this.baseAdapter.request(url, options);
        
      default:
        return await this.baseAdapter.request(url, options);
    }
  }
  
  selectRandomFaultType() {
    const types = this.chaosConfig.faultTypes;
    return types[Math.floor(Math.random() * types.length)];
  }
}
```

### Step 2: Traffic Distribution Monitor
Track request distribution across endpoints before/during/after chaos:
```javascript
class TrafficDistributionMonitor {
  constructor(rpcPool) {
    this.rpcPool = rpcPool;
    this.trafficStats = new Map();
    this.samplingActive = false;
    this.samples = [];
  }
  
  startMonitoring() {
    this.samplingActive = true;
    this.resetStats();
    
    // Sample traffic distribution every 10 seconds
    this.samplingInterval = setInterval(() => {
      this.sampleTrafficDistribution();
    }, 10000);
    
    console.log('Traffic distribution monitoring started');
  }
  
  sampleTrafficDistribution() {
    const currentStats = this.rpcPool.getEndpointStats();
    const sample = {
      timestamp: Date.now(),
      distribution: {},
      total_requests: 0
    };
    
    // Calculate request counts per endpoint
    for (const [endpoint, stats] of currentStats) {
      sample.distribution[endpoint] = {
        requests: stats.requestCount,
        success_rate: stats.successCount / stats.requestCount,
        avg_latency: stats.avgLatency,
        circuit_state: stats.circuitState || 'CLOSED'
      };
      sample.total_requests += stats.requestCount;
    }
    
    // Calculate percentages
    for (const endpoint in sample.distribution) {
      sample.distribution[endpoint].percentage = 
        (sample.distribution[endpoint].requests / sample.total_requests * 100).toFixed(1);
    }
    
    this.samples.push(sample);
    console.log('Traffic distribution sample:', sample);
  }
  
  stopMonitoring() {
    if (this.samplingInterval) {
      clearInterval(this.samplingInterval);
      this.samplingActive = false;
      console.log('Traffic distribution monitoring stopped');
    }
  }
  
  getTrafficShiftAnalysis() {
    if (this.samples.length < 3) return null;
    
    const beforeChaos = this.samples[0];
    const duringChaos = this.samples[Math.floor(this.samples.length / 2)];
    const afterChaos = this.samples[this.samples.length - 1];
    
    return {
      before: beforeChaos.distribution,
      during: duringChaos.distribution,
      after: afterChaos.distribution,
      traffic_shifted: this.calculateTrafficShift(beforeChaos, duringChaos)
    };
  }
}
```

### Step 3: Single Endpoint Chaos Test
Test system response to chaos on one endpoint:
```javascript
async testSingleEndpointChaos() {
  const targetEndpoint = 'mainnet.helius-rpc.com';
  console.log(`Starting chaos test on ${targetEndpoint}`);
  
  // Start traffic monitoring
  this.trafficMonitor.startMonitoring();
  
  // Measure baseline performance
  const baseline = await this.measureBaselinePerformance(60000); // 1 minute baseline
  
  // Enable chaos on target endpoint
  this.chaosAdapter.enableChaos({
    targetEndpoints: [targetEndpoint],
    failureRate: 0.3, // 30% failure rate
    faultTypes: ['TIMEOUT', 'ECONNRESET', 'SERVER_ERROR']
  });
  
  console.log('Chaos injection enabled - monitoring system response...');
  
  // Run test workload during chaos
  const chaosResults = await this.runTestWorkloadDuringChaos(300000); // 5 minutes with chaos
  
  // Disable chaos and measure recovery
  this.chaosAdapter.disableChaos();
  console.log('Chaos injection disabled - measuring recovery...');
  
  const recoveryResults = await this.measureRecoveryPerformance(120000); // 2 minutes recovery
  
  // Stop monitoring
  this.trafficMonitor.stopMonitoring();
  
  return {
    baseline: baseline,
    chaos_period: chaosResults,
    recovery_period: recoveryResults,
    traffic_analysis: this.trafficMonitor.getTrafficShiftAnalysis(),
    chaos_stats: this.chaosAdapter.getChaosStats()
  };
}

async runTestWorkloadDuringChaos(durationMs) {
  const startTime = Date.now();
  const results = {
    requests_attempted: 0,
    requests_successful: 0,
    circuit_breaker_trips: 0,
    endpoint_failures: new Map()
  };
  
  // Run consistent workload
  while (Date.now() - startTime < durationMs) {
    try {
      results.requests_attempted++;
      
      // Make test RPC call
      await this.rpcPool.call('getSlot', []);
      results.requests_successful++;
      
    } catch (error) {
      // Categorize failure
      const endpoint = this.extractEndpointFromError(error);
      if (endpoint) {
        results.endpoint_failures.set(endpoint, 
          (results.endpoint_failures.get(endpoint) || 0) + 1
        );
      }
      
      if (error.message.includes('circuit')) {
        results.circuit_breaker_trips++;
      }
    }
    
    await new Promise(resolve => setTimeout(resolve, 100)); // 10 rps
  }
  
  results.success_rate = results.requests_successful / results.requests_attempted;
  return results;
}