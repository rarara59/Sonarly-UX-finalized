# PROMPT RN1-CORRECTED: Historical LP Event Replay with Edge Measurement

## SINGLE FOCUS
Validate meme coin detection pipeline using concurrent historical LP event replay with competitive edge measurement

## EXPLICIT FILE PATHS
- **CREATE**: `scripts/test-historical-replay-corrected.js`
- **CREATE**: `scripts/concurrent-event-replayer.js`
- **CREATE**: `scripts/edge-scoreboard.js`
- **CREATE**: `data/historical-lp-events.ndjson` (data file)
- **CREATE**: `results/edge-analysis-results.json` (output)
- **IMPORT**: Complete refactored RPC system

## INCREMENTAL IMPLEMENTATION

### Step 1: Concurrent Event Replayer Implementation
Create replayer with in-flight task management to prevent timer storms:
```javascript
class ConcurrentEventReplayer {
  constructor(maxInFlight = 2000) {
    this.maxInFlight = maxInFlight;
    this.activeTimers = 0;
    this.eventQueue = [];
    this.processedEvents = [];
  }
  
  async replayEvents(events, speedMultiplier = 1.0) {
    const baseTime = new Date(events[0].timestamp);
    
    events.forEach(event => {
      const eventTime = new Date(event.timestamp);
      const replayDelay = (eventTime - baseTime) / speedMultiplier;
      this.scheduleEventWithBackoff(event, replayDelay);
    });
    
    await this.waitForCompletion();
    return this.processedEvents;
  }
  
  scheduleEventWithBackoff(event, delay) {
    if (this.activeTimers >= this.maxInFlight) {
      this.eventQueue.push({ event, delay });
      return;
    }
    
    setTimeout(async () => {
      try {
        const result = await this.processEvent(event);
        this.processedEvents.push(result);
      } finally {
        this.activeTimers--;
        this.processQueuedEvents();
      }
    }, delay);
    
    this.activeTimers++;
  }
  
  processQueuedEvents() {
    while (this.eventQueue.length > 0 && this.activeTimers < this.maxInFlight) {
      const { event, delay } = this.eventQueue.shift();
      this.scheduleEventWithBackoff(event, delay);
    }
  }
}
```

### Step 2: Edge Scoreboard Implementation
Create competitive advantage measurement system:
```javascript
class EdgeScoreboard {
  constructor() {
    this.edgeResults = [];
    this.retailBaselineMs = {
      p50: 180000,  // 3 minutes estimated
      p95: 420000   // 7 minutes estimated
    };
  }
  
  recordDetection(lpEvent, detectionResult) {
    const lpCreateTime = new Date(lpEvent.timestamp);
    const detectionTime = new Date(detectionResult.timestamp);
    
    const ourLatencyMs = detectionTime - lpCreateTime;
    const retailLatencyMs = this.estimateRetailDetection(lpEvent);
    const edgeSeconds = (retailLatencyMs - ourLatencyMs) / 1000;
    
    this.edgeResults.push({
      lpCreateTime,
      detectionTime,
      ourLatencyMs,
      retailLatencyMs,
      edgeSeconds,
      capturedWithin30s: ourLatencyMs <= 30000
    });
  }
  
  generateEdgeSummary() {
    const ourLatencies = this.edgeResults.map(r => r.ourLatencyMs);
    const edgeSeconds = this.edgeResults.map(r => r.edgeSeconds);
    const captureRate = this.edgeResults.filter(r => r.capturedWithin30s).length / this.edgeResults.length;
    
    return {
      events_total: this.edgeResults.length,
      our_detection_latency_ms: {
        p50: this.calculatePercentile(ourLatencies, 0.5),
        p95: this.calculatePercentile(ourLatencies, 0.95)
      },
      retail_detection_latency_ms: this.retailBaselineMs,
      edge_seconds: {
        median: this.calculatePercentile(edgeSeconds, 0.5),
        p95: this.calculatePercentile(edgeSeconds, 0.95)
      },
      opportunity_capture_≤30s_pct: Math.round(captureRate * 100)
    };
  }
  
  estimateRetailDetection(lpEvent) {
    // Simulate retail trader delay (3-7 minutes)
    return Math.random() * (420000 - 180000) + 180000;
  }
}
```

### Step 3: Historical Data Collection
Export LP events with canonical timestamps:
```javascript
const historicalLPEvents = [
  {
    timestamp: '2024-08-15T18:05:12.123Z',  // Precise LP creation time
    signature: 'abc123...',
    programId: 'RAYDIUM_AMM_V4',
    instruction: 'initialize',
    mint: 'BONK_MINT_ADDRESS',
    pool: 'POOL_ADDRESS',
    lpAmount: '1000000000',
    eventId: `lp_${Date.now()}_${Math.random()}` // Canonical ID
  }
  // ... 100+ events from high-activity period
];
```

### Step 4: Concurrent Detection Pipeline Test
Process events through detection system with concurrency control:
```javascript
async processEvent(lpEvent) {
  const startTime = Date.now();
  
  try {
    // Run through complete detection pipeline
    const enrichmentData = await this.enrichWithMainnetData(lpEvent);
    const riskAnalysis = await this.analyzeRiskFactors(enrichmentData);
    const tradingSignal = await this.generateTradingSignal(riskAnalysis);
    
    const detectionTime = Date.now();
    const processingTimeMs = detectionTime - startTime;
    
    // Record edge measurement
    this.edgeScoreboard.recordDetection(lpEvent, {
      timestamp: new Date(detectionTime),
      signal: tradingSignal,
      processingTimeMs
    });
    
    return {
      eventId: lpEvent.eventId,
      success: true,
      processingTimeMs,
      signal: tradingSignal
    };
    
  } catch (error) {
    return {
      eventId: lpEvent.eventId,
      success: false,
      error: error.message,
      processingTimeMs: Date.now() - startTime
    };
  }
}
```

### Step 5: Multi-Speed Testing
Test at both 1x and 5x speeds with separate edge measurements:
```javascript
async runMultiSpeedTest(events) {
  // 1x speed test
  console.log('Running 1x speed replay...');
  const oneXResults = await this.replayer.replayEvents(events, 1.0);
  const oneXEdge = this.edgeScoreboard.generateEdgeSummary();
  
  // Reset for 5x test
  this.edgeScoreboard.reset();
  
  // 5x speed test
  console.log('Running 5x speed replay...');
  const fiveXResults = await this.replayer.replayEvents(events, 5.0);
  const fiveXEdge = this.edgeScoreboard.generateEdgeSummary();
  
  return {
    oneX: { results: oneXResults, edge: oneXEdge },
    fiveX: { results: fiveXResults, edge: fiveXEdge }
  };
}
```

### Step 6: Results Analysis and Validation
Generate comprehensive results with competitive advantage proof:
```javascript
const finalResults = {
  test_summary: {
    events_total: historicalEvents.length,
    processed_≤30s_1x_pct: oneXResults.filter(r => r.processingTimeMs <= 30000).length / oneXResults.length * 100,
    processed_≤30s_5x_pct: fiveXResults.filter(r => r.processingTimeMs <= 30000).length / fiveXResults.length * 100,
    silent_drops: oneXResults.filter(r => !r.success && !r.error).length,
    circuit_breaker_trips: this.circuitBreakerMonitor.getTripCount()
  },
  competitive_edge: {
    oneX_speed: oneXEdge,
    fiveX_speed: fiveXEdge,
    competitive_advantage_proven: oneXEdge.edge_seconds.median >= 120 // ≥2 minutes faster
  },
  component_health: this.getComponentHealthSummary()
};
```

## CLEAR SUCCESS CRITERIA
- 99% of events processed within 30 seconds at 1x speed
- 80% of events processed within 30 seconds at 5x speed
- Zero silent drops (all events generate result or logged error)
- Edge median ≥120 seconds faster than retail detection
- Circuit breaker trips <5% of events with automatic recovery

## REQUIREMENTS-BASED VALIDATION
- **Processing Speed**: ≥99% within 30s at 1x, ≥80% at 5x speed
- **Reliability**: Zero silent drops, all events accounted for
- **Competitive Edge**: Median edge ≥120 seconds vs retail detection
- **System Stability**: Circuit breaker trips <5% with recovery
- **Concurrency Control**: No timer storms, max 2000 in-flight tasks
- **Memory Efficiency**: <100MB growth during replay test