Phase 3A: Component Pairs Integration Testing - Claude Code Optimized
SINGLE FOCUS
Create integration test suite that validates 4 critical component pairs working together with real Solana mainnet RPC calls.
EXPLICIT FILE PATHS

Create: tests/integration/component-pairs.test.js (main test suite)
Create: scripts/real-solana-test-helper.js (RPC helper utilities)
Import: All 7 components from src/detection/transport/

CLAUDE CODE IMPLEMENTATION STEPS
Step 1: Create Real Solana Test Infrastructure (30 minutes)
// File: scripts/real-solana-test-helper.js
export class RealSolanaTestHelper {
  constructor() {
    this.endpoints = {
      helius: process.env.HELIUS_RPC_URL,
      chainstack: process.env.CHAINSTACK_RPC_URL,
      public: 'https://api.mainnet-beta.solana.com'
    };
    
    // Real token addresses for testing
    this.testTokens = {
      BONK: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263',
      PEPE: 'BzLXX3siFZkiCKw2QLXfr6jXBgPkEwkMaqhwKkZcVdZu',
      WIF: 'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm'
    };
  }

  async makeRealRpcCall(endpoint, method, params) {
    // Implementation for actual Solana RPC calls
    // Include timeout, error handling, response validation
  }

  async simulateNetworkFailure(endpoint) {
    // Block/unblock specific endpoints for testing
  }
}

Step 2: Test TokenBucket + ConnectionPoolCore Pair (45 minutes)
// Test Case 1: Rate limiting prevents connection exhaustion
describe('TokenBucket + ConnectionPoolCore Integration', () => {
  test('Rate limiting prevents connection pool exhaustion under real RPC load', async () => {
    const tokenBucket = new TokenBucket({
      rateLimit: 50,  // 50 rps to test limiting
      burstCapacity: 100
    });
    
    const connectionPool = new ConnectionPoolCore({
      maxSockets: 10,  // Low limit to test exhaustion prevention
      timeout: 5000
    });
    
    // Test with REAL Solana RPC calls
    const promises = Array(200).fill().map(async (_, i) => {
      if (!tokenBucket.hasTokens()) {
        return { rejected: true, reason: 'rate_limited' };
      }
      
      tokenBucket.consume(1);
      return await connectionPool.execute(
        testHelper.endpoints.helius,
        'POST',
        {
          jsonrpc: '2.0',
          id: i,
          method: 'getAccountInfo',
          params: [testHelper.testTokens.BONK]
        }
      );
    });
    
    const results = await Promise.allSettled(promises);
    
    // Validate rate limiting worked
    const rejected = results.filter(r => r.value?.rejected).length;
    const successful = results.filter(r => r.status === 'fulfilled' && !r.value?.rejected).length;
    
    expect(rejected).toBeGreaterThan(100); // Rate limiting kicked in
    expect(successful).toBeLessThan(100);  // Pool wasn't exhausted
    expect(connectionPool.getMetrics().socketReusePercentage).toBeGreaterThan(80);
  });
});

Step 3: Test CircuitBreaker + EndpointSelector Pair (45 minutes)
// Test Case 2: Circuit breaker state affects endpoint selection
describe('CircuitBreaker + EndpointSelector Integration', () => {
  test('Circuit breaker opens and endpoint selector fails over with real network', async () => {
    // USE ACTUAL API discovered in Phase 2
    const endpointSelector = new EndpointSelector();
    endpointSelector.initializeEndpoints([  // NOT updateEndpoints!
      testHelper.endpoints.helius,
      testHelper.endpoints.chainstack,
      testHelper.endpoints.public
    ]);
    
    const circuitBreaker = new CircuitBreaker({
      failureThreshold: 6,  // Phase 2 found it opens at 6, not 5
      resetTimeout: 10000
    });
    
    // Simulate Helius outage
    await testHelper.simulateNetworkFailure(testHelper.endpoints.helius);
    
    let failureCount = 0;
    let successCount = 0;
    
    // Make real RPC calls until circuit opens
    for (let i = 0; i < 10; i++) {
      try {
        const endpoint = endpointSelector.selectEndpoint();
        const result = await circuitBreaker.execute('rpc_call', async () => {
          return await testHelper.makeRealRpcCall(
            endpoint.url,  // Phase 2 found it returns {url, health, stats}
            'getTokenSupply',
            [testHelper.testTokens.BONK]
          );
        });
        
        endpointSelector.markEndpointSuccess(endpoint, 200);
        successCount++;
      } catch (error) {
        const endpoint = endpointSelector.selectEndpoint();
        endpointSelector.markEndpointFailed(endpoint, error);
        failureCount++;
      }
    }
    
    // Validate circuit opened and failover worked
    expect(circuitBreaker.getState()).toBe('OPEN');
    expect(endpointSelector.getHealthyEndpoints().length).toBeLessThan(3);
    expect(successCount).toBeGreaterThan(0); // Some calls succeeded via failover
  });
});

Step 4: Test RequestCache + BatchManager Pair (45 minutes)
// Test Case 3: Cached responses don't break batch routing with real data
describe('RequestCache + BatchManager Integration', () => {
  test('Cache and batching work together with real Solana responses', async () => {
    const requestCache = new RequestCache({
      maxEntries: 1000,
      defaultTTL: 5000  // 5 second cache for testing
    });
    
    const batchManager = new BatchManager({
      batchWindow: 100,   // 100ms batching window
      maxBatchSize: 10
    });
    
    // Real meme coin trading pattern
    const tradingRequests = [
      { method: 'getTokenSupply', params: [testHelper.testTokens.BONK] },
      { method: 'getTokenSupply', params: [testHelper.testTokens.BONK] }, // Duplicate for cache test
      { method: 'getAccountInfo', params: [testHelper.testTokens.PEPE] },
      { method: 'getTokenSupply', params: [testHelper.testTokens.WIF] },
      { method: 'getTokenSupply', params: [testHelper.testTokens.BONK] }, // Another duplicate
    ];
    
    const results = [];
    const startTime = Date.now();
    
    for (const request of tradingRequests) {
      const cacheKey = requestCache.generateKey(request.method, request.params);
      
      const result = await requestCache.get(cacheKey, async () => {
        return await batchManager.addRequest(request.method, request.params, async (batchedRequests) => {
          // Execute real batched RPC call
          return await testHelper.makeRealRpcCall(
            testHelper.endpoints.helius,
            'batch',
            batchedRequests.map((req, id) => ({
              jsonrpc: '2.0',
              id,
              method: req.method,
              params: req.params
            }))
          );
        });
      });
      
      results.push(result);
    }
    
    // Validate cache effectiveness and batch routing accuracy
    const metrics = requestCache.getMetrics();
    const batchMetrics = batchManager.getMetrics();
    
    expect(metrics.hitRate).toBeGreaterThan(30); // Some cache hits from duplicates
    expect(batchMetrics.efficiencyPercentage).toBeGreaterThan(60); // Some batching occurred
    expect(results.length).toBe(5); // All requests got responses
    expect(results[0].value.lamports).toBeDefined(); // Real Solana response format
  });
});

Step 5: Test HedgedManager + EndpointSelector Pair (45 minutes)
// Test Case 4: Hedged requests use different endpoints under real network conditions
describe('HedgedManager + EndpointSelector Integration', () => {
  test('Hedged requests improve success rate with real network latency', async () => {
    const endpointSelector = new EndpointSelector();
    endpointSelector.initializeEndpoints([
      testHelper.endpoints.helius,    // Usually fastest
      testHelper.endpoints.chainstack, 
      testHelper.endpoints.public     // Usually slowest
    ]);
    
    const hedgedManager = new HedgedManager({
      hedgingDelay: 200,  // 200ms before backup request
      maxBackups: 2
    });
    
    let primaryEndpointUsed = null;
    let backupEndpointsUsed = [];
    
    // Make real hedged request
    const result = await hedgedManager.hedgedRequest(
      async () => {
        const endpoint = endpointSelector.selectEndpoint();
        primaryEndpointUsed = endpoint.url;
        
        return await testHelper.makeRealRpcCall(
          endpoint.url,
          'getTokenLargestAccounts',
          [testHelper.testTokens.BONK, { commitment: 'confirmed' }]
        );
      },
      [
        async () => {
          const endpoint = endpointSelector.selectEndpoint();
          backupEndpointsUsed.push(endpoint.url);
          
          return await testHelper.makeRealRpcCall(
            endpoint.url,
            'getTokenLargestAccounts', 
            [testHelper.testTokens.BONK, { commitment: 'confirmed' }]
          );
        }
      ]
    );
    
    // Validate hedging worked with real endpoints
    expect(result.value).toBeDefined(); // Got real response
    expect(result.value.length).toBeGreaterThan(0); // Valid token accounts
    expect(primaryEndpointUsed).toBeDefined();
    
    // Validate different endpoints were used
    if (backupEndpointsUsed.length > 0) {
      expect(backupEndpointsUsed).not.toContain(primaryEndpointUsed);
    }
  });
});

SUCCESS CRITERIA VALIDATION
Performance Requirements (Real Network Adjusted)

Network latency tolerance: Component pairs add <50ms to 200ms+ base RPC calls
Real data handling: Zero type errors with actual Solana response formats
Cache effectiveness: >30% hit rate with realistic trading patterns
Success rate improvement: Hedging/failover shows >10% improvement during network issues

Validation Commands
// Run with real environment variables set:
// HELIUS_RPC_URL=https://mainnet.helius-rpc.com/?api-key=YOUR_KEY
// CHAINSTACK_RPC_URL=https://solana-mainnet.core.chainstack.com/YOUR_KEY

npm test tests/integration/component-pairs.test.js

// Expected output:
// ✅ TokenBucket + ConnectionPoolCore: Rate limiting prevents exhaustion
// ✅ CircuitBreaker + EndpointSelector: Failover works with real outages  
// ✅ RequestCache + BatchManager: Cache + batching accurate with real data
// ✅ HedgedManager + EndpointSelector: Hedged requests use different endpoints

CLAUDE CODE EXECUTION NOTES
Critical Implementation Requirements

Use Phase 2 discovered APIs: initializeEndpoints(), threshold 6, endpoint objects
Real network calls only: No mocks, use actual Solana mainnet endpoints
Handle real response formats: Solana account data, lamport amounts, base64 encoding
Test during different network conditions: Peak vs off-peak hours
Measure actual component overhead: Latency added to real 200ms+ RPC calls

Error Handling Patterns
// Template for all component pair tests
try {
  const result = await componentA.integrate(componentB, realSolanaData);
  // Validate with real response data
  expect(result.lamports).toBeDefined(); // Solana-specific validation
} catch (error) {
  // Test error handling with real network failures
  expect(error.code).toMatch(/ECONNRESET|ETIMEDOUT|ENOTFOUND/);
}

