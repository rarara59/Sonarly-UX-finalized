PROMPT 4.0B-REVISED: Component Integration Validation
SINGLE FOCUS
Validate component orchestration with realistic request patterns to ensure integrated system works correctly
EXPLICIT FILE PATHS

CREATE: scripts/validate-component-integration.js
CREATE: results/integration-validation.json (output file)
IMPORT: src/detection/transport/rpc-manager.js from 4.0A

INCREMENTAL IMPLEMENTATION
Step 1: Initialize RPC Manager with Production Config
Create production-like configuration and initialize system:

const config = {
  rateLimiting: { rateLimit: 50, windowMs: 1000, maxBurst: 75 },
  circuitBreaker: { failureThreshold: 6, cooldownPeriod: 5000 },
  connectionPool: { maxSockets: 20, maxSocketsPerHost: 10 },
  endpoints: {
    strategy: 'round-robin',
    urls: ['https://mainnet.helius-rpc.com', 'https://api.mainnet-beta.solana.com']
  },
  cache: { maxSize: 1000, defaultTTL: 15000 },
  batching: { maxBatchSize: 10, timeoutMs: 100 },
  hedging: { enabled: true, delayMs: 200 }
};

const rpcManager = new RpcManager(config);

Step 2: Execute Token Supply Request
Test getTokenSupply and validate response format:

const tokenResult = await rpcManager.call('getTokenSupply', [BONK_MINT_ADDRESS]);
console.log('Token supply result:', tokenResult);
// Validate: result.value.decimals exists
// Validate: result.value.amount is string

Step 3: Execute Balance Check Request
Test getBalance and validate lamports field:

const balanceResult = await rpcManager.call('getBalance', [WALLET_ADDRESS]);
console.log('Balance result:', balanceResult);
// Validate: result.value.lamports exists
// Validate: result.value.lamports is number

Step 4: Execute Account Info Request
Test getAccountInfo and validate account data:

const accountResult = await rpcManager.call('getAccountInfo', [ACCOUNT_ADDRESS]);
console.log('Account info result:', accountResult);
// Validate: result.value exists (null if account doesn't exist, or account data)

Step 5: Run Mixed Request Pattern
Execute 10 mixed requests and measure success rate:

const requests = [
  ['getTokenSupply', [BONK_MINT_ADDRESS]],
  ['getBalance', [WALLET_ADDRESS]],
  ['getTokenSupply', [WIF_MINT_ADDRESS]],
  ['getBalance', [WALLET_ADDRESS]], // Duplicate for cache testing
  ['getAccountInfo', [ACCOUNT_ADDRESS]],
  ['getSlot', []],
  ['getTokenSupply', [BONK_MINT_ADDRESS]], // Duplicate for cache testing
  ['getBalance', [WALLET_ADDRESS_2]],
  ['getTokenSupply', [PEPE_MINT_ADDRESS]],
  ['getSlot', []] // Duplicate for cache testing
];

let successCount = 0;
const results = [];

for (const [method, params] of requests) {
  try {
    const result = await rpcManager.call(method, params);
    results.push({ method, params, success: true, result });
    successCount++;
  } catch (error) {
    results.push({ method, params, success: false, error: error.message });
  }
}

Step 6: Validate Cache Behavior
Check cache hit/miss patterns from duplicate requests:

// Count expected cache hits from duplicate requests in Step 5
const expectedCacheHits = 3; // 3 duplicate requests
const cacheStats = rpcManager.requestCache.getStats();
console.log('Cache stats:', cacheStats);
// Validate: cache hits > 0
// Validate: cache shows hit/miss activity

Step 7: Save Integration Results
Save validation results to JSON file:

const integrationResults = {
  timestamp: new Date().toISOString(),
  totalRequests: requests.length,
  successfulRequests: successCount,
  successRate: successCount / requests.length,
  cacheStats: cacheStats,
  componentHealth: {
    rateLimiter: rpcManager.tokenBucket.isHealthy(),
    circuitBreaker: rpcManager.circuitBreaker.getState(),
    connectionPool: rpcManager.connectionPool.getStats(),
    endpointSelector: rpcManager.endpointSelector.getAvailableEndpoints().length,
    requestCache: rpcManager.requestCache.getStats(),
    batchManager: rpcManager.batchManager.getStats(),
    hedgedManager: rpcManager.hedgedManager.getStats()
  },
  requestResults: results
};

await fs.writeFile('results/integration-validation.json', JSON.stringify(integrationResults, null, 2));

CLEAR SUCCESS CRITERIA

RpcManager completes 10 consecutive requests without errors
Success rate >90% for mixed request types
Cache shows expected hit/miss patterns
All responses contain valid Solana data fields

REQUIREMENTS-BASED VALIDATION

Success Rate: >90% for 10 mixed RPC requests
Response Validation: All responses contain expected Solana fields (lamports, decimals, value)
Cache Functionality: Shows cache hits for duplicate requests (>0 hits)
Component Health: All 7 components remain functional after test
Performance: Average request completion <10 seconds per request
Data Output: Integration results saved to JSON for analysis
Error Handling: Failed requests don't crash the system
Resource Management: No memory leaks or resource exhaustion during test