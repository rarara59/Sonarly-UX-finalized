PROMPT 1A: Token Bucket Extraction
SINGLE FOCUS: Extract rate limiting logic from existing 2000-line RPC connection pool
EXPLICIT FILE PATHS:

Source: src/detection/transport/rpc-connection-pool.js (lines containing "rate", "limit", "throttle", "rps", "bucket")
Target: src/detection/transport/token-bucket.js

INCREMENTAL IMPLEMENTATION PROCESS:
Step 1: Extract rate limiting variables, configuration, and token bucket algorithm from source file
Step 2: Create TokenBucket class with constructor, hasTokens(), and replenish() methods
Step 3: Test TokenBucket class in isolation with various rate limiting scenarios
Step 4: Create integration stub in original file: this.tokenBucket.hasTokens() ready for Phase 3
Step 5: Verify original file still compiles and functions with integration stub
CLEAR SUCCESS CRITERIA:
Functional Requirements:

TokenBucket processes 1000 requests/sec with <10ms latency per token check
Rate limiting accuracy: 95%+ (properly rejects requests when token bucket exhausted)
Memory usage: <50MB for 100,000 token operations during sustained load
Configuration loading: All rate limiting environment variables properly loaded and validated

Performance Requirements:

Token consumption check: <1ms per hasTokens() call under normal load
Token replenishment accuracy: Within 1% of configured rate over time windows
Burst handling: Allows 2x normal rate for up to 10 seconds as configured
Memory stability: No memory leaks during 1-hour continuous operation

Integration Requirements:

Original file compiles successfully after extraction with integration stub
Integration interface: this.tokenBucket.hasTokens() method ready for orchestrator
Export functionality: import { TokenBucket } from './token-bucket.js' works correctly
Configuration compatibility: Existing environment variables work unchanged

REQUIREMENTS-BASED VALIDATION:
Measure These Metrics:

Rate limiting accuracy percentage (target: 95%+ rejection accuracy when over limit)
Token check latency in milliseconds (target: <1ms per hasTokens() call)
Memory usage during sustained operation (target: <50MB for extended operation)
Burst tolerance effectiveness (target: 2x rate handling for 10 seconds)
Configuration loading success rate (target: 100% for valid environment variables)