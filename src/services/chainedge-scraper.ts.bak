'Sniper,Gem Spotter,Early Mover': 0
    };

    for (const [address, categories] of this.crossCategoryWallets.entries()) {
      if (categories.length > 1) {
        const key = categories.sort().join(',');

        // Only count keys that match our predefined categories
        if (crossCategoryCount.hasOwnProperty(key)) {
          const typedKey = key as keyof typeof crossCategoryCount;
          crossCategoryCount[typedKey]++;
        }

        // Update wallet in database with cross-category information
        this.updateWalletCrossCategoryInfo(address, categories);
      }
    }

    logger.info('Cross-category wallet counts:', crossCategoryCount);
  }

  /**
   * ENHANCED: Update wallet with cross-category information
   */
  private async updateWalletCrossCategoryInfo(address: string, categories: string[]): Promise<void> {
    try {
      const wallet = await ExternalWallet.findOne({ address });

      if (wallet) {
        // Add cross-category metadata
        wallet.metadata = {
          ...wallet.metadata,
          categoryCrossover: categories
        };

        // Boost reputation score for wallets in multiple categories
        // Multi-category wallets tend to have higher success rates
        const crossoverBoost = (categories.length - 1) * 5; // +5 per additional category
        wallet.reputationScore = Math.min(100, (wallet.reputationScore || 0) + crossoverBoost);

        await wallet.save();
        logger.info(`Updated wallet ${address} with cross-category information: ${categories.join(', ')}`);
      }
    } catch (error) {
      logger.error(`Error updating cross-category info for wallet ${address}:`, error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * ENHANCED: Adjust thresholds based on scraping results
   * This helps maintain the target 74-76% success rate
   */
  private async adjustThresholdsBasedOnResults(): Promise<void> {
    try {
      // Calculate current overall success rate
      const wallets = await ExternalWallet.find({});

      if (wallets.length === 0) {
        logger.info('No wallets found for threshold adjustment');
        return;
      }

      // Calculate average win rate across all wallets
      const totalWinRate = wallets.reduce((sum, wallet) => sum + wallet.winRate, 0);
      const averageWinRate = totalWinRate / wallets.length;

      // Store for logging
      this.stats.lastSuccessRate = averageWinRate;

      logger.info(`Current average success rate: ${averageWinRate.toFixed(2)}%`);

      // Check if we're within target range
      if (averageWinRate >= this.config.targetSuccessRate.min && 
          averageWinRate <= this.config.targetSuccessRate.max) {
        logger.info('Success rate is within target range, no adjustment needed');
        return;
      }

      // Adjust thresholds to move toward target range
      if (averageWinRate < this.config.targetSuccessRate.min) {
        // Increase minimum win rate threshold
        const adjustment = Math.min(5, this.config.targetSuccessRate.min - averageWinRate);
        this.config.minWinRate += adjustment;
        logger.info(`Increased minimum win rate threshold to ${this.config.minWinRate}% (+${adjustment}%)`);
      } else if (averageWinRate > this.config.targetSuccessRate.max) {
        // Decrease minimum win rate threshold or increase other quality metrics
        const adjustment = Math.min(5, averageWinRate - this.config.targetSuccessRate.max);
        // Instead of just lowering win rate, we can also increase other quality requirements
        // to maintain high quality while adjusting success rate
        this.config.minPnL *= (1 + adjustment/100);
        this.config.minTrades += Math.round(adjustment/2);
        logger.info(`Adjusted quality thresholds: minPnL=${this.config.minPnL}, minTrades=${this.config.minTrades}`);
      }

      this.stats.adaptiveThresholdAdjustments++;
    } catch (error) {
      logger.error('Error adjusting thresholds:', error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * ENHANCED: Find a working selector from a list of options
   */
  private async findWorkingSelector(selectors: string[], context: string): Promise<string | null> {
    if (!this.page) return null;

    for (const selector of selectors) {
      try {
        const elements = await this.page.$(selector);
        if (elements.length > 0) {
          logger.info(`Found working selector for ${context}: ${selector}`);
          return selector;
        }
      } catch (error) {
        // Ignore errors and try next selector
      }
    }

    // Nothing found
    logger.warn(`No working selector found for ${context}`);
    return null;
  }

  /**
   * ENHANCED: Advanced logic to find and click category filter
   */
  private async findAndClickCategoryFilter(category: string): Promise<{success: boolean, reason?: string}> {
    if (!this.page) return {success: false, reason: 'Browser not initialized'};

    try {
      // First try direct category-specific selectors
      const categorySelectors = [
        `.${category.toLowerCase().replace(/\s+/g, '-')}-filter`,
        `[data-category="${category.toLowerCase().replace(/\s+/g, '-')}"]`,
        `button:contains("${category}")`,
        `.filter button:contains("${category}")`,
        `.category-filter button:contains("${category}")`,
        `#${category.toLowerCase().replace(/\s+/g, '-')}-filter`
      ];

      // Check for successful selector in history
      const historicalSelector = this.getSuccessfulSelector(category, 'categoryButton');
      if (historicalSelector) {
        categorySelectors.unshift(historicalSelector); // Try this first
      }

      // Try clicking each selector
      for (const selector of categorySelectors) {
        const elements = await this.page.$(selector);
        if (elements.length > 0) {
          // Found a matching element, try to click it
          await elements[0].click();
          await this.page.waitForTimeout(1000);
          
          // Record successful selector
          this.recordSelectorSuccess(category, 'categoryButton', selector);
          
          logger.info(`Clicked ${category} filter with selector: ${selector}`);
          return {success: true};
        }
      }

      // If direct selectors failed, try more general text-search approach
      logger.info(`Direct selectors failed for ${category}, trying text search approach`);

      // Try to find and click any element with text containing the category
      const foundByText = await this.page.evaluate((categoryText) => {
        const elements = Array.from(document.querySelectorAll('button, .button, [role="button"], .filter-item, .category-item, a[href*="category"]'));

        for (const element of elements) {
          if (element.textContent && element.textContent.includes(categoryText)) {
            (element as HTMLElement).click();
            return {found: true, text: element.textContent.trim()};
          }
        }

        return {found: false};
      }, category);

      if (foundByText.found) {
        await this.page.waitForTimeout(1000);
        logger.info(`Clicked ${category} filter by text content: ${foundByText.text}`);
        return {success: true};
      }

      // Try to find any visible filter toggle and click it
      const filterToggleSelector = '.filter-toggle, .filters-button, button:contains("Filter"), button:contains("Categories")';
      const filterToggle = await this.page.$(filterToggleSelector);

      if (filterToggle) {
        logger.info('Found filter toggle, clicking it first');
        await filterToggle.click();
        await this.page.waitForTimeout(1000);

        // Try again after clicking filter toggle
        const retryResult = await this.findAndClickCategoryFilter(category);
        return retryResult;
      }

      // If all attempts failed, take a screenshot for debugging
      await this.page.screenshot({ path: `category-filter-failed-${category}.png` });
      return {success: false, reason: `Could not find ${category} filter`};
    } catch (error) {
      logger.error(`Error finding category filter for ${category}:`, error instanceof Error ? error.message : String(error));
      return {success: false, reason: error instanceof Error ? error.message : String(error)};
    }
  }

  /**
   * ENHANCED: Find and click filter button
   */
  private async findAndClickFilterButton(): Promise<{success: boolean, reason?: string}> {
    if (!this.page) return {success: false, reason: 'Browser not initialized'};

    try {
      const filterButtonSelectors = [
        '.advanced-filter', 
        '.filter-button', 
        'button:contains("Filter")', 
        '.filter-toggle',
        'button[aria-label*="filter" i]',
        'button[title*="filter" i]',
        '.filter',
        '#filter-button'
      ];

      // Try each selector
      for (const selector of filterButtonSelectors) {
        const filterButton = await this.page.$(selector);
        if (filterButton) {
          logger.info(`Found filter button with selector: ${selector}`);
          await filterButton.click();
          await this.page.waitForTimeout(2000);
          return {success: true};
        }
      }

      // If direct selectors failed, try text search approach
      logger.info('Filter button not found with direct selectors, trying text search approach');

      const foundByText = await this.page.evaluate(() => {
        const textOptions = ['Filter', 'Filters', 'Advanced', 'Search', 'Advanced Filter', 'Advanced Search'];
        const elements = Array.from(document.querySelectorAll('button, .button, [role="button"]'));

        for (const element of elements) {
          if (element.textContent) {
            for (const text of textOptions) {
              if (element.textContent.includes(text)) {
                (element as HTMLElement).click();
                return {found: true, text: element.textContent.trim()};
              }
            }
          }
        }

        return {found: false};
      });

      if (foundByText.found) {
        await this.page.waitForTimeout(2000);
        logger.info(`Clicked filter button by text content: ${foundByText.text}`);
        return {success: true};
      }

      // If all attempts failed, take a screenshot for debugging
      await this.page.screenshot({ path: 'filter-button-failed.png' });
      return {success: false, reason: 'Could not find filter button'};
    } catch (error) {
      logger.error('Error finding filter button:', error instanceof Error ? error.message : String(error));
      return {success: false, reason: error instanceof Error ? error.message : String(error)};
    }
  }

  /**
   * ENHANCED: Fill filter form with adaptive thresholds
   */
  private async fillFilterForm(category: string): Promise<string[]> {
    if (!this.page) return [];

    try {
      // Get optimized threshold values based on category success rates
      const thresholds = this.getOptimizedThresholds(category);

      return await this.page.evaluate((config) => {
        const fieldsFilled = [];

        // Function to find and fill an input field
        const findAndFill = (selectors: string[], value: string): boolean => {
          for (const selector of selectors) {
            const input = document.querySelector(selector);
            if (input) {
              (input as HTMLInputElement).value = '';
              (input as HTMLInputElement).value = value;
              return true;
            }
          }
          return false;
        };

        // Try to find win rate input
        const winRateSelectors = [
          'input[name="winRate"]', 
          'input[placeholder*="Win Rate"]', 
          'input[aria-label*="Win Rate"]',
          'input[name="win_rate"]',
          'input[placeholder*="win"]',
          'input[placeholder*="success"]'
        ];

        if (findAndFill(winRateSelectors, config.thresholds.minWinRate.toString())) {
          fieldsFilled.push('winRate');
        }

        // Try to find PNL input
        const pnlSelectors = [
          'input[name="pnl"]', 
          'input[placeholder*="PNL"]', 
          'input[aria-label*="PNL"]',
          'input[name="profit"]',
          'input[placeholder*="profit"]'
        ];

        if (findAndFill(pnlSelectors, config.thresholds.minPnL.toString())) {
          fieldsFilled.push('pnl');
        }

        // Try to find trades input
        const tradesSelectors = [
          'input[name="trades"]', 
          'input[placeholder*="Trades"]', 
          'input[aria-label*="Trades"]',
          'input[name="trade_count"]',
          'input[placeholder*="transactions"]'
        ];

        if (findAndFill(tradesSelectors, config.thresholds.minTrades.toString())) {
          fieldsFilled.push('trades');
        }

        // Try to find min buy value input
        const buyValueSelectors = [
          'input[name="minBuy"]', 
          'input[placeholder*="Min Buy"]', 
          'input[aria-label*="Min Buy"]',
          'input[name="min_value"]'
        ];

        if (findAndFill(buyValueSelectors, config.thresholds.minBuyValue.toString())) {
          fieldsFilled.push('minBuy');
        }

        // Fill any additional filters that might help target 74-76% success rate

        // Look for hold time filters if we're filtering by timeframe
        if (config.timeframeFilters.fastTimeframe || config.timeframeFilters.slowTimeframe) {
          const holdTimeSelectors = [
            'input[name="holdTime"]',
            'input[placeholder*="Hold Time"]',
            'input[aria-label*="Hold Time"]',
            'input[name="hold_time"]',
            'input[placeholder*="holding"]',
            'input[placeholder*="duration"]'
          ];
          
          let holdTimeValue = '';
          if (config.timeframeFilters.fastTimeframe && !config.timeframeFilters.slowTimeframe) {
            holdTimeValue = '0-4h'; // Fast timeframe
          } else if (!config.timeframeFilters.fastTimeframe && config.timeframeFilters.slowTimeframe) {
            holdTimeValue = '4h-48h'; // Slow timeframe
          }
          
          if (holdTimeValue && findAndFill(holdTimeSelectors, holdTimeValue)) {
            fieldsFilled.push('holdTime');
          }
        }

        return fieldsFilled;
      }, {
        thresholds,
        timeframeFilters: this.config.timeframeFilters
      });
    } catch (error) {
      logger.error('Error filling filter form:', error instanceof Error ? error.message : String(error));
      return [];
    }
  }

  /**
   * ENHANCED: Get optimized threshold values based on category success rates
   */
  private getOptimizedThresholds(category: string): {
    minWinRate: number;
    minPnL: number;
    minTrades: number;
    minBuyValue: number;
  } {
    // Start with base thresholds
    const thresholds = {
      minWinRate: this.config.minWinRate,
      minPnL: this.config.minPnL,
      minTrades: this.config.minTrades,
      minBuyValue: this.config.minBuyValue
    };

    // If we have category-specific success rate data, adjust thresholds
    const categorySuccessRate = this.categorySuccessRates[category] || 0;

    if (categorySuccessRate > 0) {
      // If category success rate is too high, lower threshold slightly
      if (categorySuccessRate > this.config.targetSuccessRate.max) {
        const adjustment = Math.min(5, categorySuccessRate - this.config.targetSuccessRate.max);
        thresholds.minWinRate = Math.max(70, thresholds.minWinRate - adjustment);
        logger.info(`Lowering win rate threshold for ${category} to ${thresholds.minWinRate}% (-${adjustment}%)`);
      }
      // If category success rate is too low, raise threshold slightly
      else if (categorySuccessRate < this.config.targetSuccessRate.min) {
        const adjustment = Math.min(5, this.config.targetSuccessRate.min - categorySuccessRate);
        thresholds.minWinRate = Math.min(95, thresholds.minWinRate + adjustment);
        logger.info(`Raising win rate threshold for ${category} to ${thresholds.minWinRate}% (+${adjustment}%)`);
      }
    }

    // Category-specific adjustments based on past data
    if (category === 'Sniper') {
      // Snipers typically have higher trade counts but might have lower individual PnL
      thresholds.minTrades = Math.round(thresholds.minTrades * 1.2); // 20% more trades
      thresholds.minPnL = Math.round(thresholds.minPnL * 0.9); // 10% less PnL
    } else if (category === 'Gem Spotter') {
      // Gem spotters might have fewer trades but higher PnL
      thresholds.minTrades = Math.round(thresholds.minTrades * 0.9); // 10% fewer trades
      thresholds.minPnL = Math.round(thresholds.minPnL * 1.2); // 20% more PnL
    } else if (category === 'Early Mover') {
      // Early movers might have moderate trade counts but very high 4x consistency
      thresholds.minBuyValue = Math.round(thresholds.minBuyValue * 0.8); // 20% lower buy threshold
    }

    return thresholds;
  }

  /**
   * ENHANCED: Submit filter form with adaptive selector strategy
   */
  private async submitFilterForm(): Promise<{success: boolean, reason?: string}> {
    if (!this.page) return {success: false, reason: 'Browser not initialized'};

    try {
      const submitSelectors = [
        'button[type="submit"]', 
        'button:contains("Apply")', 
        'button:contains("Submit")', 
        'button:contains("Search")', 
        'button:contains("Filter")',
        'input[type="submit"]',
        '.submit-button',
        '.search-button',
        '.apply-button',
        '.apply-filters',
        'button.primary'
      ];

      // Try each submit selector
      for (const selector of submitSelectors) {
        const submitButton = await this.page.$(selector);
        if (submitButton) {
          logger.info(`Found submit button with selector: ${selector}`);
          await Promise.all([
            this.page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 30000 }).catch(() => {
              logger.info('Navigation timeout after submit - continuing anyway');
            }),
            submitButton.click()
          ]);
          return {success: true};
        }
      }

      // If direct selectors failed, try text-based search
      logger.info('Submit button not found with direct selectors, trying text search approach');

      const foundByText = await this.page.evaluate(() => {
        const buttonTexts = ['Apply', 'Submit', 'Search', 'Filter', 'Apply Filters', 'Done', 'OK'];
        const buttons = Array.from(document.querySelectorAll('button, .button, [role="button"], input[type="submit"]'));

        for (const button of buttons) {
          if (button.textContent) {
            for (const text of buttonTexts) {
              if (button.textContent.includes(text)) {
                (button as HTMLElement).click();
                return {found: true, text: button.textContent.trim()};
              }
            }
          }
        }

        return {found: false};
      });

      if (foundByText.found) {
        await this.page.waitForTimeout(3000); // Wait a bit longer since we're not using waitForNavigation
        logger.info(`Clicked submit button by text content: ${foundByText.text}`);
        return {success: true};
      }

      // Look for the most likely primary/submit button based on styling
      const primaryButton = await this.page.evaluate(() => {
        // Look for buttons with styling that suggests they're primary/submit buttons
        const buttons = Array.from(document.querySelectorAll('button, .button, [role="button"]'));

        // Check for buttons with typical primary button styling classes
        const stylingKeywords = [
          'primary', 'submit', 'blue', 'green', 'cta', 'main', 
          'action', 'confirm', 'positive', 'success'
        ];

        for (const button of buttons) {
          const classList = (button as HTMLElement).className || '';
          for (const keyword of stylingKeywords) {
            if (classList.includes(keyword)) {
              (button as HTMLElement).click();
              return {found: true, class: classList};
            }
          }
        }

        // If no button found by class, look for the most prominent button
        // (this is a fallback and might not be accurate)
        const visibleButtons = buttons.filter((b) => {
          const style = window.getComputedStyle(b);
          return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
        });

        if (visibleButtons.length > 0) {
          // Click the last visible button (often the submit button is last)
          const lastButton = visibleButtons[visibleButtons.length - 1];
          (lastButton as HTMLElement).click();
          return {found: true, position: 'last'};
        }

        return {found: false};
      });

      if (primaryButton.found) {
        await this.page.waitForTimeout(3000);
        logger.info(`Clicked submit button based on styling/position: ${JSON.stringify(primaryButton)}`);
        return {success: true};
      }

      // If all attempts failed, take a screenshot for debugging
      await this.page.screenshot({ path: 'submit-button-failed.png' });
      return {success: false, reason: 'Could not find submit button'};
    } catch (error) {
      logger.error('Error submitting filter form:', error instanceof Error ? error.message : String(error));
      return {success: false, reason: error instanceof Error ? error.message : String(error)};
    }
  }

  /**
   * ENHANCED: Verify we're on the expected page type
   */
  private async verifyCurrentPage(pageType: string): Promise<boolean> {
    if (!this.page) return false;

    try {
      return await this.page.evaluate((type) => {
        // Check URL patterns
        const url = window.location.href;

        if (type === 'dashboard') {
          if (url.includes('/dashboard') || url.includes('/home') || 
              url.includes('/wallets') || url.includes('/traders')) {
            return true;
          }
          
          // Check for dashboard elements
          return !!(
            document.querySelector('.dashboard') || 
            document.querySelector('.home-page') || 
            document.querySelector('.wallet-list') ||
            document.querySelector('h1:contains("Dashboard")') ||
            document.querySelector('h1:contains("Wallets")') ||
            document.querySelector('.nav-dashboard.active')
          );
        } else if (type === 'wallet-detail') {
          if (url.includes('/wallet/') || url.includes('/address/') || 
              url.includes('/trader/')) {
            return true;
          }
          
          // Check for wallet detail elements
          return !!(
            document.querySelector('.wallet-detail') || 
            document.querySelector('.address-detail') ||
            document.querySelector('.transaction-list') ||
            document.querySelector('.transactions-table')
          );
        }

        return false;
      }, pageType);
    } catch (error) {
      logger.error(`Error verifying current page type (${pageType}):`, error instanceof Error ? error.message : String(error));
      return false;
    }
  }

  /**
   * ENHANCED: Get successful selector from history
   */
  private getSuccessfulSelector(category: string, selectorType: string): string | null {
    const history = this.selectorHistory[category]?.[selectorType];
    if (history && history.successCount > 0 && history.selector) {
      return history.selector;
    }
    return null;
  }

  /**
   * ENHANCED: Record selector success
   */
  private recordSelectorSuccess(category: string, selectorType: string, selector: string): void {
    if (!this.selectorHistory[category]) {
      this.selectorHistory[category] = {};
    }
    if (!this.selectorHistory[category][selectorType]) {
      this.selectorHistory[category][selectorType] = {
        selector: '',
        successCount: 0,
        failCount: 0,
        lastSuccess: null,
        lastFail: null
      };
    }

    const history = this.selectorHistory[category][selectorType];
    history.selector = selector;
    history.successCount++;
    history.lastSuccess = new Date();
  }

  /**
   * ENHANCED: Record selector failure
   */
  private recordSelectorFailure(category: string, selectorType: string, selector: string): void {
    if (!this.selectorHistory[category]) {
      this.selectorHistory[category] = {};
    }
    if (!this.selectorHistory[category][selectorType]) {
      this.selectorHistory[category][selectorType] = {
        selector: '',
        successCount: 0,
        failCount: 0,
        lastSuccess: null,
        lastFail: null
      };
    }

    const history = this.selectorHistory[category][selectorType];
    // Only record if this is the current selector
    if (history.selector === selector) {
      history.failCount++;
      history.lastFail = new Date();
    }
  }

  /**
   * ENHANCED: Predict wallet success rate based on metrics
   */
  private predictWalletSuccessRate(wallet: EnhancedWalletData): number {
    // Start with the reported win rate
    let predictedRate = wallet.winRate || 0;

    // Adjust based on historical data and patterns

    // 1. Category-specific adjustments
    if (wallet.category === 'Sniper') {
      // Snipers often maintain their success rate
      // No adjustment needed
    } else if (wallet.category === 'Gem Spotter') {
      // Gem spotters might have slightly lower success rate in practice
      predictedRate *= 0.97; // 3% drop
    } else if (wallet.category === 'Early Mover') {
      // Early movers might have slightly higher variance
      predictedRate *= 0.95; // 5% drop
    }

    // 2. Trade count adjustments - more trades = more reliable prediction
    if (wallet.totalTrades && wallet.totalTrades < 50) {
      // Lower trade counts might overestimate success
      predictedRate *= 0.95 + (wallet.totalTrades / 1000); // Up to 5% reduction
    }

    // 3. PnL adjustments - higher PnL might indicate more selective trading
    if (wallet.totalPnL && wallet.totalPnL > 100000) {
      // Higher PnL can indicate better trade selection
      predictedRate *= 1.01; // Small 1% boost
    }

    // 4. Cross-category bonus
    if (wallet.address) {
      const categories = this.crossCategoryWallets.get(wallet.address) || [];
      if (categories.length > 1) {
        // Wallets in multiple categories tend to be more reliable
        predictedRate *= 1 + (0.01 * (categories.length - 1)); // 1% boost per additional category
      }
    }

    // 5. 4x return consistency factor
    if (wallet.returns4xConsistency && wallet.returns4xConsistency > 30) {
      // Wallets with good 4x consistency tend to maintain success rates
      predictedRate *= 1.02; // 2% boost
    }

    // Cap at 100%
    return Math.min(100, predictedRate);
  }

  /**
   * ENHANCED: Calculate confidence score for wallet data quality
   */
  private calculateWalletConfidenceScore(wallet: EnhancedWalletData): number {
    let score = 50; // Start with neutral confidence

    // Factors that increase confidence

    // 1. More trades = more confidence
    if (wallet.totalTrades && wallet.totalTrades > 0) {
      score += Math.min(25, wallet.totalTrades / 4); // Up to 25 points for 100+ trades
    }

    // 2. Recent activity
    if (wallet.lastUpdated) {
      const daysSinceUpdate = (Date.now() - wallet.lastUpdated.getTime()) / (24 * 60 * 60 * 1000);
      if (daysSinceUpdate < 7) {
        score += 10; // +10 for activity within last week
      } else if (daysSinceUpdate < 30) {
        score += 5; // +5 for activity within last month
      }
    }

    // 3. Cross-category presence
    if (wallet.address) {
      const categories = this.crossCategoryWallets.get(wallet.address) || [];
      score += categories.length * 5; // +5 per category
    }

    // 4. Success pattern consistency
    if (wallet.winRate && wallet.winRate > 0 && wallet.winRate < 100) {
      // Extremely high win rates might be suspicious
      // More realistic win rates (60-90%) get higher confidence
      const realisticBonus = wallet.winRate >= 60 && wallet.winRate <= 90 ? 10 : 0;
      score += realisticBonus;
    }

    // 5. Data completeness
    if (wallet.address && wallet.winRate && wallet.totalPnL && 
        wallet.totalTrades && wallet.avgHoldTime) {
      score += 10; // +10 for complete basic data
    }

    // Cap at 0-100 range
    return Math.max(0, Math.min(100, score));
  }

  /**
   * ENHANCED: Extract wallet data with improved robustness
   */
  private async extractWalletData(category: string): Promise<EnhancedWalletData[]> {
    if (!this.page) return [];

    // Take a screenshot before extraction to help debug
    await this.page.screenshot({ path: `before-extraction-${category}.png` });

    // Extract wallet data with more adaptive approach
    try {
      // Try DOM analysis first to determine the data structure
      const domAnalysis = await this.analyzeDOMForWalletData();

      // Extract wallet data based on DOM analysis
      return await this.page.evaluate((params) => {
        const { category, domAnalysis } = params;
        const wallets: any[] = [];

        // Function to extract text by trying multiple selectors
        const extractTextBySelectors = (element: Element, selectors: string[], defaultValue: string = ''): string => {
          for (const selector of selectors) {
            try {
              const el = element.querySelector(selector);
              if (el && el.textContent) {
                return el.textContent.trim();
              }
            } catch (e) {
              // Ignore errors and try next selector
            }
          }
          return defaultValue;
        };

        // Function to parse numeric values from strings with K/M suffixes
        const parseNumericValue = (text: string): number => {
          if (!text) return 0;
          
          const cleanText = text.replace(/[$,]/g, '').trim();
          
          if (cleanText.includes('K') || cleanText.includes('k')) {
            return parseFloat(cleanText.replace(/[Kk]/g, '')) * 1000;
          } else if (cleanText.includes('M') || cleanText.includes('m')) {
            return parseFloat(cleanText.replace(/[Mm]/g, '')) * 1000000;
          } else {
            return parseFloat(cleanText) || 0;
          }
        };

        // Try different possible table/list selectors based on DOM analysis
        let walletElements: NodeListOf<Element> | null = null;
        let usedSelector = '';

        // Start with the container selectors from DOM analysis
        for (const selector of domAnalysis.containerSelectors) {
          const elements = document.querySelectorAll(selector);
          if (elements && elements.length > 0) {
            walletElements = elements;
            usedSelector = selector;
            break;
          }
        }

        // If no elements found with container selectors, try a more generic approach
        if (!walletElements || walletElements.length === 0) {
          console.warn('No wallet elements found with container selectors, trying generic approach');
          
          // Look for any table rows or grid items
          walletElements = document.querySelectorAll('tr, .grid > div, .list > div, .card');
          usedSelector = 'generic';
        }

        if (!walletElements || walletElements.length === 0) {
          console.warn('No wallet elements found with any selector');
          return wallets;
      }, { category, domAnalysis });
    } catch (error) {
      logger.error(`Error extracting wallet data for ${category}:`, error instanceof Error ? error.message : String(error));

      // Fallback to simpler extraction if DOM analysis fails
      return await this.fallbackExtractWalletData(category);
    }
  }

  /**
   * ENHANCED: Analyze DOM to determine data structure
   */
  private async analyzeDOMForWalletData(): Promise<{
    containerSelectors: string[];
    addressSelectors: string[];
    winRateSelectors: string[];
    pnlSelectors: string[];
    tradesSelectors: string[];
    holdTimeSelectors: string[];
  }> {
    if (!this.page) return {
      containerSelectors: [],
      addressSelectors: [],
      winRateSelectors: [],
      pnlSelectors: [],
      tradesSelectors: [],
      holdTimeSelectors: []
    };

    try {
      return await this.page.evaluate(() => {
        const analysis = {
          containerSelectors: [] as string[],
          addressSelectors: [] as string[],
          winRateSelectors: [] as string[],
          pnlSelectors: [] as string[],
          tradesSelectors: [] as string[],
          holdTimeSelectors: [] as string[]
        };

        // Find potential container elements for wallet rows
        const tables = document.querySelectorAll('table');
        const lists = document.querySelectorAll('ul, ol');
        const grids = document.querySelectorAll('.grid, .card-grid, [class*="grid"]');

        // 1. Check tables first (most common)
        tables.forEach((table, tableIndex) => {
          const rows = table.querySelectorAll('tbody tr');
          if (rows.length >= 3) { // Need at least a few rows
            // This looks like a data table
            analysis.containerSelectors.push(`table:nth-of-type(${tableIndex + 1}) tbody tr`);
            
            // Analyze header row to determine column purposes
            const headerRow = table.querySelector('thead tr');
            if (headerRow) {
              const headers = Array.from(headerRow.querySelectorAll('th, td'));
              
              headers.forEach((header, colIndex) => {
                const headerText = header.textContent?.toLowerCase() || '';
                
                // Determine column type based on header text
                if (headerText.includes('address') || headerText.includes('wallet') || 
                    headerText.includes('trader') || headerText.includes('id')) {
                  // Address column
                  analysis.addressSelectors.push(`table:nth-of-type(${tableIndex + 1}) tbody tr td:nth-child(${colIndex + 1})`);
                } else if (headerText.includes('win') || headerText.includes('success') || 
                           headerText.includes('rate') || headerText.includes('wr') || 
                           headerText.includes('%')) {
                  // Win rate column
                  analysis.winRateSelectors.push(`table:nth-of-type(${tableIndex + 1}) tbody tr td:nth-child(${colIndex + 1})`);
                } else if (headerText.includes('pnl') || headerText.includes('profit') || 
                           headerText.includes('loss') || headerText.includes('earnings')) {
                  // PNL column
                  analysis.pnlSelectors.push(`table:nth-of-type(${tableIndex + 1}) tbody tr td:nth-child(${colIndex + 1})`);
                } else if (headerText.includes('trade') || headerText.includes('transaction') || 
                           headerText.includes('tx') || headerText.includes('count')) {
                  // Trades column
                  analysis.tradesSelectors.push(`table:nth-of-type(${tableIndex + 1}) tbody tr td:nth-child(${colIndex + 1})`);
                } else if (headerText.includes('hold') || headerText.includes('duration') || 
                           headerText.includes('time') || headerText.includes('period')) {
                  // Hold time column
                  analysis.holdTimeSelectors.push(`table:nth-of-type(${tableIndex + 1}) tbody tr td:nth-child(${colIndex + 1})`);
                }
              });
            }
          }
        });

        // 2. Check lists
        lists.forEach((list, listIndex) => {
          const items = list.querySelectorAll('li');
          if (items.length >= 3) {
            // This might be a list of wallets
            analysis.containerSelectors.push(`${list.tagName.toLowerCase()}:nth-of-type(${listIndex + 1}) > li`);
            
            // Analyze the first item to determine structure
            const firstItem = items[0];
            
            // Look for elements with class names or texts that suggest data types
            const elements = firstItem.querySelectorAll('*');
            elements.forEach((el) => {
              const className = el.className || '';
              const text = el.textContent?.toLowerCase() || '';
              
              if (className.includes('address') || className.includes('wallet') || 
                  className.includes('id') || text.includes('0x')) {
                // Address element
                analysis.addressSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              } else if (className.includes('win') || className.includes('rate') || 
                         className.includes('success') || text.includes('%')) {
                // Win rate element
                analysis.winRateSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              } else if (className.includes('pnl') || className.includes('profit') || 
                         text.includes('
        }

        console.log(`Found ${walletElements.length} wallet elements with selector: ${usedSelector}`);

        // Process each wallet element
        Array.from(walletElements).forEach((row, index) => {
          try {
            // Extract address with multiple approaches
            let address = '';
            
            // Try DOM analysis address columns
            for (const selector of domAnalysis.addressSelectors) {
              const addressElement = row.querySelector(selector);
              if (addressElement) {
                // Try text content first
                address = addressElement.textContent?.trim() || '';
                
                // If address looks truncated, try attributes
                if (address.includes('...')) {
                  address = addressElement.getAttribute('data-address') || 
                           addressElement.getAttribute('title') || 
                           addressElement.getAttribute('data-original') || 
                           address;
                }
                
                // If we found a valid address, break
                if (address && !address.includes('...')) {
                  break;
                }
              }
            }
            
            // If no address found, try extracting from generic elements
            if (!address || address.includes('...')) {
              const addressSelectors = [
                '.address', '.wallet-address', '[data-address]', '.address-text',
                'a[href*="wallet/"]', 'a[href*="address/"]', '[title*="0x"]',
                'td:nth-child(1)', '.address-column', '.wallet-id', '.trader-id'
              ];
              
              address = extractTextBySelectors(row, addressSelectors);
              
              // If address contains ellipsis, try to get from data attribute or title
              if (!address || address.includes('...')) {
                const addressEl = row.querySelector(addressSelectors.join(', '));
                if (addressEl) {
                  address = addressEl.getAttribute('data-address') || 
                           addressEl.getAttribute('title') || 
                           addressEl.getAttribute('data-original') || 
                           address;
                }
              }
              
              // Try to extract from href if nothing else worked
              if (!address || address.includes('...')) {
                const link = row.querySelector('a[href*="wallet/"], a[href*="address/"]');
                if (link) {
                  const href = link.getAttribute('href') || '';
                  const matches = href.match(/\/(wallet|address)\/([^/?#]+)/);
                  if (matches && matches[2]) {
                    address = matches[2];
                  }
                }
              }
            }
            
            // Skip if no valid address found
            if (!address || address.includes('...')) {
              console.warn(`Row ${index} skipped: Invalid address "${address}"`);
              return;
            }
            
            // Extract win rate with multiple approaches
            let winRateText = '';
            let winRate = 0;
            
            // Try DOM analysis win rate columns
            for (const selector of domAnalysis.winRateSelectors) {
              const winRateElement = row.querySelector(selector);
              if (winRateElement) {
                winRateText = winRateElement.textContent?.trim() || '';
                winRate = parseFloat(winRateText.replace(/%/g, '')) || 0;
                if (winRate > 0) {
                  break;
                }
              }
            }
            
            // If no win rate found, try generic selectors
            if (winRate === 0) {
              const winRateSelectors = [
                '.win-rate', '.success-rate', '[data-win-rate]', '.wr',
                '.win-percentage', 'td:nth-child(2)', '.win-rate-column',
                '.success-percentage', '.rate', '.win-pct'
              ];
              winRateText = extractTextBySelectors(row, winRateSelectors, '0%');
              winRate = parseFloat(winRateText.replace(/%/g, '')) || 0;
            }
            
            // Extract PNL with multiple approaches
            let pnlText = '';
            let totalPnL = 0;
            
            // Try DOM analysis PNL columns
            for (const selector of domAnalysis.pnlSelectors) {
              const pnlElement = row.querySelector(selector);
              if (pnlElement) {
                pnlText = pnlElement.textContent?.trim() || '';
                totalPnL = parseNumericValue(pnlText);
                if (totalPnL > 0) {
                  break;
                }
              }
            }
            
            // If no PNL found, try generic selectors
            if (totalPnL === 0) {
              const pnlSelectors = [
                '.pnl', '.profit', '[data-pnl]', '.profit-loss',
                '.earnings', 'td:nth-child(3)', '.pnl-column',
                '.total-profit', '.net-profit', '.p-n-l'
              ];
              pnlText = extractTextBySelectors(row, pnlSelectors, '$0');
              totalPnL = parseNumericValue(pnlText);
            }
            
            // Extract trades with multiple approaches
            let tradesText = '';
            let successfulTrades = 0;
            let totalTrades = 0;
            
            // Try DOM analysis trades columns
            for (const selector of domAnalysis.tradesSelectors) {
              const tradesElement = row.querySelector(selector);
              if (tradesElement) {
                tradesText = tradesElement.textContent?.trim() || '';
                
                // Handle different formats
                if (tradesText) {
                  if (tradesText.includes('/')) {
                    // Format like "225/646"
                    const parts = tradesText.split('/');
                    successfulTrades = parseInt(parts[0].trim()) || 0;
                    totalTrades = parseInt(parts[1].trim()) || 0;
                  } else {
                    // Just total trades
                    totalTrades = parseInt(tradesText.replace(/[^0-9]/g, '')) || 0;
                    // Estimate successful trades based on win rate
                    successfulTrades = Math.round(totalTrades * (winRate / 100));
                  }
                  
                  if (totalTrades > 0) {
                    break;
                  }
                }
              }
            }
            
            // If no trades found, try generic selectors
            if (totalTrades === 0) {
              const tradesSelectors = [
                '.trades', '.trade-count', '[data-trades]', '.transactions',
                '.tx-count', 'td:nth-child(4)', '.trades-column',
                '.number-of-trades', '.total-trades'
              ];
              tradesText = extractTextBySelectors(row, tradesSelectors, '0/0');
              
              if (tradesText.includes('/')) {
                // Format like "225/646"
                const parts = tradesText.split('/');
                successfulTrades = parseInt(parts[0].trim()) || 0;
                totalTrades = parseInt(parts[1].trim()) || 0;
              } else {
                // Just total trades
                totalTrades = parseInt(tradesText.replace(/[^0-9]/g, '')) || 0;
                // Estimate successful trades based on win rate
                successfulTrades = Math.round(totalTrades * (winRate / 100));
              }
            }
            
            // Extract hold time with multiple approaches
            let avgHoldTime = '';
            
            // Try DOM analysis hold time columns
            for (const selector of domAnalysis.holdTimeSelectors) {
              const holdTimeElement = row.querySelector(selector);
              if (holdTimeElement) {
                avgHoldTime = holdTimeElement.textContent?.trim() || '';
                if (avgHoldTime) {
                  break;
                }
              }
            }
            
            // If no hold time found, try generic selectors
            if (!avgHoldTime) {
              const holdTimeSelectors = [
                '.hold-time', '.avg-hold', '[data-hold-time]', '.duration',
                '.holding-period', 'td:nth-child(5)', '.hold-time-column',
                '.average-hold-time', '.avg-duration'
              ];
              avgHoldTime = extractTextBySelectors(row, holdTimeSelectors, '');
            }
            
            // Extract any other useful metrics if available
            
            // 4x consistency (if available)
            let returns4xConsistency = 0;
            const returns4xSelectors = [
              '.returns-4x', '.x4-rate', '[data-4x-rate]', '.x4-percentage',
              '.multiplier-rate', '.high-returns-rate'
            ];
            const returns4xText = extractTextBySelectors(row, returns4xSelectors);
            if (returns4xText) {
              returns4xConsistency = parseFloat(returns4xText.replace(/%/g, '')) || 0;
            }
            
            // Add wallet to results if it has valid data
            if (address && (winRate > 0 || totalPnL > 0)) {
              wallets.push({
                address,
                network: 'solana', // Default to Solana
                category,
                winRate,
                totalPnL,
                successfulTrades,
                totalTrades,
                avgHoldTime,
                isActive: true,
                lastUpdated: new Date(),
                returns4xConsistency,
                // Add metadata for enhanced analysis
                metadata: {
                  tradingFrequency: 
                    totalTrades >= 500 ? 'Very High' : 
                    totalTrades >= 200 ? 'High' : 
                    totalTrades >= 50 ? 'Medium' : 
                    totalTrades >= 10 ? 'Low' : 'Very Low'
                }
              });
            }
          } catch (error) {
            console.error(`Error parsing wallet row ${index}:`, error);
          }
        });

        return wallets;import puppeteer from 'puppeteer';
import { logger } from '../utils/logger';
import path from 'path';
import fs from 'fs';
import { ExternalWallet, IExternalWallet } from '../models/externalWallet';
import { connectToDatabase } from '../utils/database';
import { ClassifiedTransaction, EnhancedWalletData } from '../types/wallet';
import config from '../config';

// Scraper configuration type
interface ChainEDGEConfig {
  baseUrl: string;
  username: string;
  password: string;
  minWinRate: number;
  minPnL: number;
  minTrades: number;
  minTokensTraded: number;
  minBuyValue: number;
  scrapeInterval: number; // in milliseconds
  walletCategories: {
    sniper: boolean;
    gemSpotter: boolean;
    earlyMover: boolean;
  };
  timeframeFilters: {
    fastTimeframe: boolean; // 1-4 hour trades
    slowTimeframe: boolean; // 4-48 hour trades
  };
  // New optimization parameters
  targetSuccessRate: {
    min: number; // Minimum target success rate (e.g., 74)
    max: number; // Maximum target success rate (e.g., 76)
  };
  dataCacheTTL: number; // Cache time-to-live in milliseconds
  parallelProcessing: boolean; // Enable parallel processing
  maxRetries: number; // Maximum number of retries for failed operations
  retryDelay: number; // Initial delay between retries in milliseconds
  cacheDirectory: string; // Directory to store cache files
  adaptiveThresholds: boolean; // Dynamically adjust thresholds based on results
}

// Time-specific success metrics interface
interface TimeframeMetrics {
  totalTrades: number;
  successfulTrades: number;
  winRate: number;
  avgMultiplier: number;
  avgHoldTime: number; // in minutes
}

// Transaction with timeframe classification
interface ClassifiedTransaction extends IWalletTransaction {
  timeframe: 'fast' | 'slow' | 'other';
  holdTimeMinutes: number;
  multiplier: number;
  meta?: {
    timeframeSuccessRate?: number;
    isMemeToken?: boolean;
    entryTimingScore?: number;
  };
}

// Enhanced wallet data with timeframe-specific metrics
interface EnhancedWalletData extends Partial<IExternalWallet> {
  fastTimeframeMetrics?: TimeframeMetrics;
  slowTimeframeMetrics?: TimeframeMetrics;
  memeTokenMetrics?: {
    totalTrades: number;
    successfulTrades: number;
    winRate: number;
    avgMultiplier: number;
  };
  patternSuccessRates?: Record<string, number>;
  entryTiming?: number; // How early they typically get in (percentile)
  exitEfficiency?: number; // How close to top they typically exit (percentile)
  recentTransactions?: ClassifiedTransaction[];
  // New fields for success rate prediction
  predictedSuccessRate?: number;
  confidenceScore?: number; // How confident we are in the data quality
  categoryCrossover?: string[]; // Categories this wallet appears in
  returns4xConsistency?: number; // Consistency score for 4x returns
}

// Interface for selector history tracking
interface SelectorHistory {
  selector: string;
  successCount: number;
  failCount: number;
  lastSuccess: Date | null;
  lastFail: Date | null;
}

// Interface for tracking scraping jobs
interface ScrapingJobStats {
  startTime: Date;
  endTime: Date | null;
  category: string;
  walletsFound: number;
  highQualityWallets: number;
  errors: string[];
  success: boolean;
  currentSuccessRate: number | null;
}

export class ChainEDGEScraper {
  private browser: puppeteer.Browser | null = null;
  private page: puppeteer.Page | null = null;
  private config: ChainEDGEConfig;
  private isLoggedIn = false;
  private isRunning = false;
  private stats = {
    totalWalletsSeen: 0,
    walletsProcessed: 0,
    transactionsProcessed: 0,
    highValueWallets: 0,
    scrapingJobs: [] as ScrapingJobStats[],
    lastSuccessRate: null as number | null,
    adaptiveThresholdAdjustments: 0
  };

  // New fields for enhanced functionality
  private selectorHistory: Record<string, Record<string, SelectorHistory>> = {};
  private walletCache: Map<string, { data: EnhancedWalletData, timestamp: number }> = new Map();
  private knownSuccessfulWallets: Set<string> = new Set();
  private activeScrapingJobs: number = 0;
  private categorySuccessRates: Record<string, number> = {
    'Sniper': 0,
    'Gem Spotter': 0,
    'Early Mover': 0
  };
  private crossCategoryWallets: Map<string, string[]> = new Map();

  constructor(config?: Partial<ChainEDGEConfig>) {
    // Default configuration with values optimized for meme coin detection
    this.config = {
      baseUrl: config?.baseUrl || 'https://app.chainedge.io',
      username: config?.username || process.env.CHAINEDGE_USERNAME || '',
      password: config?.password || process.env.CHAINEDGE_PASSWORD || '',
      minWinRate: config?.minWinRate || 75, // Targeting high win rate for 74-76% success goal
      minPnL: config?.minPnL || 50000, // Minimum $50k profit to ensure quality
      minTrades: config?.minTrades || 30, // Statistically significant number
      minTokensTraded: config?.minTokensTraded || 10, // Ensure diverse trading history
      minBuyValue: config?.minBuyValue || 500, // Minimum buy value to filter out small trades
      scrapeInterval: config?.scrapeInterval || 3600000, // Default 1 hour
      walletCategories: {
        sniper: config?.walletCategories?.sniper !== undefined ? config.walletCategories.sniper : true,
        gemSpotter: config?.walletCategories?.gemSpotter !== undefined ? config.walletCategories.gemSpotter : true,
        earlyMover: config?.walletCategories?.earlyMover !== undefined ? config.walletCategories.earlyMover : true,
      },
      timeframeFilters: {
        fastTimeframe: config?.timeframeFilters?.fastTimeframe !== undefined ? config.timeframeFilters.fastTimeframe : true,
        slowTimeframe: config?.timeframeFilters?.slowTimeframe !== undefined ? config.timeframeFilters.slowTimeframe : true,
      },
      // New optimization parameters
      targetSuccessRate: {
        min: config?.targetSuccessRate?.min || 74,
        max: config?.targetSuccessRate?.max || 76
      },
      dataCacheTTL: config?.dataCacheTTL || 24 * 60 * 60 * 1000, // 24 hours by default
      parallelProcessing: config?.parallelProcessing || false, // Default to false for stability
      maxRetries: config?.maxRetries || 3,
      retryDelay: config?.retryDelay || 1000,
      cacheDirectory: config?.cacheDirectory || path.join(process.cwd(), 'cache'),
      adaptiveThresholds: config?.adaptiveThresholds !== undefined ? config.adaptiveThresholds : true
    };

    // Create cache directory if it doesn't exist
    if (!fs.existsSync(this.config.cacheDirectory)) {
      fs.mkdirSync(this.config.cacheDirectory, { recursive: true });
    }

    // Initialize selector history for categories
    const categories = ['Sniper', 'Gem Spotter', 'Early Mover'];
    const selectorTypes = [
      'categoryButton', 'filterButton', 'winRateInput', 
      'pnlInput', 'tradesInput', 'submitButton'
    ];

    categories.forEach(category => {
      this.selectorHistory[category] = {};
      selectorTypes.forEach(type => {
        this.selectorHistory[category][type] = {
          selector: '',
          successCount: 0,
          failCount: 0,
          lastSuccess: null,
          lastFail: null
        };
      });
    });

    // Load cached wallet data if available
    this.loadWalletCache();

    // Validate config
    this.validateConfig();
  }

  /**
   * Get current configuration
   */
  getConfig(): ChainEDGEConfig {
    return this.config;
  }

  /**
   * Validate configuration parameters
   */
  private validateConfig(): void {
    if (!this.config.username || !this.config.password) {
      throw new Error('ChainEDGE username and password are required');
    }

    // At least one wallet category must be enabled
    if (!this.config.walletCategories.sniper && 
        !this.config.walletCategories.gemSpotter && 
        !this.config.walletCategories.earlyMover) {
      throw new Error('At least one wallet category must be enabled');
    }

    // At least one timeframe filter must be enabled
    if (!this.config.timeframeFilters.fastTimeframe && 
        !this.config.timeframeFilters.slowTimeframe) {
      throw new Error('At least one timeframe filter must be enabled');
    }

    // Validate target success rate
    if (this.config.targetSuccessRate.min < 0 || 
        this.config.targetSuccessRate.max > 100 ||
        this.config.targetSuccessRate.min > this.config.targetSuccessRate.max) {
      throw new Error('Invalid target success rate range');
    }
  }

  /**
   * Initialize the scraper
   */
  async initialize(): Promise<boolean> {
    try {
      logger.info('Initializing ChainEDGE scraper');

      // Launch browser with stealth mode for better detection avoidance
      this.browser = await puppeteer.launch({
        headless: false, // Change to false to see the browser in action
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--disable-infobars',
          '--window-size=1920,1080',
          '--disable-gpu',
          '--disable-extensions'
        ],
        ignoreHTTPSErrors: true
      });

      // Create a new page
      this.page = await this.browser.newPage();

      // Set user agent to avoid detection
      await this.page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36');

      // Set viewport size
      await this.page.setViewport({ width: 1920, height: 1080 });

      // Enable stealth mode
      await this.page.evaluateOnNewDocument(() => {
        // Hide webdriver
        Object.defineProperty(navigator, 'webdriver', {
          get: () => false
        });

        // Hide Chrome
        window.navigator.chrome = {
          runtime: {} as any
        };

        // Hide Automation
        window.navigator.languages = ['en-US', 'en'];

        // Overwrite permissions
        const originalQuery = window.navigator.permissions.query;
        window.navigator.permissions.query = (parameters: any) => {
          return (parameters.name === 'notifications' 
            ? Promise.resolve({ state: Notification.permission }) 
            : originalQuery(parameters)) as any;
        };
      });

      // Log in to ChainEDGE
      await this.login();

      logger.info('ChainEDGE scraper initialized successfully');
      return true;
    } catch (error) {
      logger.error('Failed to initialize ChainEDGE scraper:', error instanceof Error ? error.message : String(error));
      await this.cleanup();
      return false;
    }
  }

  /**
   * Log in to ChainEDGE
   */
  private async login(): Promise<void> {
    if (!this.page) {
      throw new Error('Browser not initialized');
    }

    try {
      logger.info('Logging in to ChainEDGE');

      // Navigate to the login page with next parameter
      await this.page.goto(`${this.config.baseUrl}/login/?next=/`, {
        waitUntil: 'networkidle2',
        timeout: 60000
      });

      // Take screenshot for debugging
      await this.page.screenshot({ path: 'login-page.png' });
      logger.info('Saved login page screenshot to login-page.png');

      // Wait for login form to load - add more selector variations
      await this.page.waitForSelector('input[type="email"], input[name="email"], input#email, input[placeholder*="Email"], input[placeholder*="email"]', { timeout: 10000 });

      // Add delay to ensure page is ready
      await this.page.waitForTimeout(1000);

      // Fill in login form - adjust selectors as needed
      const emailSelector = 'input[type="email"], input[name="email"], input#email, input[placeholder*="Email"], input[placeholder*="email"]';
      await this.page.type(emailSelector, this.config.username);

      const passwordSelector = 'input[type="password"], input[name="password"], input#password, input[placeholder*="Password"], input[placeholder*="password"]';
      await this.page.type(passwordSelector, this.config.password);

      // Add delay before clicking
      await this.page.waitForTimeout(1000);

      // Click login button with more options
      const loginButtonSelector = 'button[type="submit"], button:contains("Sign In"), button:contains("Login"), button.login-button, input[type="submit"]';

      // Take screenshot before clicking login
      await this.page.screenshot({ path: 'before-login-click.png' });

      await Promise.all([
        this.page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 60000 }).catch(() => {
          logger.warn('Navigation timeout after login attempt - continuing anyway');
        }),
        this.page.click(loginButtonSelector)
      ]);

      // Add extra wait time for potential redirects after login
      await this.page.waitForTimeout(5000);

      // Take screenshot after login attempt
      await this.page.screenshot({ path: 'after-login.png' });

      // Check if login was successful - updated for more potential dashboard elements
      const isLoggedIn = await this.page.evaluate(() => {
        // Look for elements that would indicate successful login
        return !document.querySelector('input[type="password"]') && 
               (document.querySelector('.user-profile, .dashboard, .nav-dashboard, .logged-in, .account-info, .user-menu, .profile-section') !== null);
      });

      if (!isLoggedIn) {
        // Take screenshot of the failed login page
        await this.page.screenshot({ path: 'login-failed.png' });
        throw new Error('Login failed - could not verify successful login. See login-failed.png');
      }

      this.isLoggedIn = true;
      logger.info('Successfully logged in to ChainEDGE');
    } catch (error) {
      logger.error('Failed to log in to ChainEDGE:', error instanceof Error ? error.message : String(error));
      throw new Error(`Authentication failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Start scheduled scraping
   */
  async startScheduledScraping(): Promise<void> {
    if (this.isRunning) {
      logger.warn('Scraper is already running');
      return;
    }

    try {
      this.isRunning = true;

      // Initial scrape
      await this.scrapeWallets();

      // Set up interval for recurring scrapes
      setInterval(async () => {
        if (!this.isRunning) return;

        try {
          // Only run if no active scraping jobs
          if (this.activeScrapingJobs === 0) {
            await this.scrapeWallets();
          } else {
            logger.warn(`Skipping scheduled scrape - ${this.activeScrapingJobs} active scraping jobs`);
          }
        } catch (error) {
          logger.error('Error in scheduled scrape:', error instanceof Error ? error.message : String(error));
          
          // Try to reinitialize if needed
          if (!this.isLoggedIn || !this.page) {
            logger.info('Attempting to reinitialize scraper...');
            await this.initialize();
          }
        }
      }, this.config.scrapeInterval);

      logger.info(`Scheduled scraping started with ${this.config.scrapeInterval / 60000} minute interval`);
    } catch (error) {
      this.isRunning = false;
      logger.error('Failed to start scheduled scraping:', error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * Stop scheduled scraping
   */
  async stopScheduledScraping(): Promise<void> {
    this.isRunning = false;
    logger.info('Scheduled scraping stopped');
  }

  /**
   * Scrape wallet data from ChainEDGE
   */
  async scrapeWallets(): Promise<void> {
    if (!this.isLoggedIn || !this.page) {
      await this.initialize();
    }

    try {
      logger.info('Starting to scrape wallet data from ChainEDGE');

      // Get enabled wallet categories
      const categories: string[] = [];
      if (this.config.walletCategories.sniper) categories.push('Sniper');
      if (this.config.walletCategories.gemSpotter) categories.push('Gem Spotter');
      if (this.config.walletCategories.earlyMover) categories.push('Early Mover');

      // Process each category
      if (this.config.parallelProcessing) {
        // Process categories in parallel
        await Promise.all(categories.map(category => this.scrapeWalletsByCategory(category)));
      } else {
        // Process categories sequentially
        for (const category of categories) {
          await this.scrapeWalletsByCategory(category);
        }
      }

      // After all categories are processed, check for wallets appearing in multiple categories
      this.identifyCrossCategoryWallets();

      // Adjust thresholds if adaptive thresholds are enabled
      if (this.config.adaptiveThresholds) {
        await this.adjustThresholdsBasedOnResults();
      }

      // Save wallet cache
      this.saveWalletCache();

      logger.info(`Wallet data scraping completed. Stats: ${JSON.stringify(this.stats)}`);
    } catch (error) {
      logger.error('Error scraping wallet data:', error instanceof Error ? error.message : String(error));
      throw error;
    }
  }

  /**
   * ENHANCED: Scrape wallets for a specific category with improved resilience and accuracy
   */
  private async scrapeWalletsByCategory(category: string): Promise<void> {
    if (!this.page) return;

    // Track job stats
    const jobStats: ScrapingJobStats = {
      startTime: new Date(),
      endTime: null,
      category,
      walletsFound: 0,
      highQualityWallets: 0,
      errors: [],
      success: false,
      currentSuccessRate: null
    };

    this.activeScrapingJobs++;
    this.stats.scrapingJobs.push(jobStats);

    try {
      logger.info(`Scraping ${category} wallets`);

      let retryCount = 0;
      let success = false;

      // Retry loop with exponential backoff
      while (!success && retryCount < this.config.maxRetries) {
        try {
          // If retry, wait with exponential backoff
          if (retryCount > 0) {
            const delay = this.config.retryDelay * Math.pow(2, retryCount - 1);
            logger.info(`Retry ${retryCount}/${this.config.maxRetries} for ${category} after ${delay}ms`);
            await this.page.waitForTimeout(delay);
          }
          
          // Navigate to main dashboard page
          await this.page.goto(`${this.config.baseUrl}/dashboard`, { 
            waitUntil: 'networkidle2',
            timeout: 60000
          });
          
          // Take a screenshot of the dashboard for debugging
          const screenshotPath = `dashboard-${category}-${new Date().toISOString().replace(/:/g, '-')}.png`;
          await this.page.screenshot({ path: screenshotPath });
          logger.info(`Saved dashboard screenshot to ${screenshotPath}`);
          
          // Verify we're on the dashboard page
          const onDashboard = await this.verifyCurrentPage('dashboard');
          if (!onDashboard) {
            throw new Error('Not on dashboard page');
          }
          
          // Wait for the page to fully load with adaptive selector strategy
          const contentSelector = await this.findWorkingSelector([
            '.content', '.dashboard', '.main-content', '.container', 
            '.filter-button', '.category-filter', '[data-category]',
            // Add structure-based selectors that are less likely to change
            'div[class*="dashboard"]', 'div[class*="content"]', 'main', 'div[role="main"]'
          ], 'dashboardContent');
          
          if (!contentSelector) {
            throw new Error('Could not find dashboard content');
          }
          
          await this.page.waitForSelector(contentSelector, { timeout: 15000 }).catch(() => {
            logger.warn('Could not find expected dashboard elements - continuing anyway');
          });
          
          // Wait for a moment to ensure the dashboard is fully loaded
          await this.page.waitForTimeout(3000);
          
          // ENHANCED: Use adaptive selector system to find category filter elements
          const filterResult = await this.findAndClickCategoryFilter(category);
          if (!filterResult.success) {
            throw new Error(`Could not select ${category} filter: ${filterResult.reason}`);
          }
          
          // Wait for results to load
          await this.page.waitForTimeout(2000);
          
          // Take screenshot after category selection
          await this.page.screenshot({ path: `after-category-selection-${category}.png` });
          
          // ENHANCED: Use adaptive selector system to find and click filter button
          const filterButtonResult = await this.findAndClickFilterButton();
          if (!filterButtonResult.success) {
            throw new Error(`Could not click filter button: ${filterButtonResult.reason}`);
          }
          
          // Wait for filter dialog to appear with adaptive selector strategy
          await this.page.waitForSelector('input, form, .filter-form, .modal', { timeout: 15000 }).catch(() => {
            logger.warn('Could not find filter form elements - continuing anyway');
          });
          
          // Take screenshot of filter dialog
          await this.page.screenshot({ path: `filter-dialog-${category}.png` });
          
          // ENHANCED: Adaptively fill filter form with optimized values based on target success rate
          const filledFields = await this.fillFilterForm(category);
          logger.info(`Filter fields filled: ${filledFields.join(', ')}`);
          
          // Take screenshot after filling the filter form
          await this.page.screenshot({ path: `filter-form-filled-${category}.png` });
          
          // ENHANCED: Submit the filter form with adaptive selector system
          const submitResult = await this.submitFilterForm();
          if (!submitResult.success) {
            throw new Error(`Could not submit filter form: ${submitResult.reason}`);
          }
          
          // Wait for results to load with random delay to avoid detection
          const randomWait = 2000 + Math.random() * 1000;
          await this.page.waitForTimeout(randomWait);
          
          // Take screenshot of results
          await this.page.screenshot({ path: `results-${category}.png` });
          
          // ENHANCED: Extract wallet data with improved robustness
          const wallets = await this.extractWalletData(category);
          this.stats.totalWalletsSeen += wallets.length;
          jobStats.walletsFound = wallets.length;
          
          logger.info(`Found ${wallets.length} ${category} wallets`);
          
          // ENHANCED: Apply dynamic filtering based on target success rate
          const highQualityWallets = await this.filterHighQualityWallets(wallets, category);
          this.stats.highValueWallets += highQualityWallets.length;
          jobStats.highQualityWallets = highQualityWallets.length;
          
          logger.info(`Found ${highQualityWallets.length} high quality ${category} wallets`);
          
          // ENHANCED: Process wallets with success prediction and cross-referencing
          await this.processWalletsBatch(highQualityWallets, category);
          
          // Mark success
          success = true;
          
          // Update category success rate
          const processedWallets = await ExternalWallet.find({ category });
          if (processedWallets.length > 0) {
            const successRateSum = processedWallets.reduce((sum, wallet) => sum + wallet.winRate, 0);
            this.categorySuccessRates[category] = successRateSum / processedWallets.length;
            jobStats.currentSuccessRate = this.categorySuccessRates[category];
          }
          
          logger.info(`Processed ${highQualityWallets.length} ${category} wallets with estimated success rate: ${this.categorySuccessRates[category].toFixed(2)}%`);
        } catch (error) {
          retryCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger.error(`Error (attempt ${retryCount}/${this.config.maxRetries}) scraping ${category} wallets: ${errorMessage}`);
          
          // If we still have retries, take a screenshot and continue
          if (retryCount < this.config.maxRetries) {
            await this.page.screenshot({ path: `error-${category}-retry${retryCount}.png` });
          } else {
            // Log the error to job stats
            jobStats.errors.push(errorMessage);
            throw error; // Re-throw to be caught by outer try-catch
          }
        }
      }

      // If we exit the loop successfully
      if (success) {
        jobStats.success = true;
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to scrape ${category} wallets after ${this.config.maxRetries} attempts: ${errorMessage}`);
      jobStats.errors.push(errorMessage);
    } finally {
      // Update job stats
      jobStats.endTime = new Date();
      this.activeScrapingJobs--;
    }
  }

  /**
   * ENHANCED: Process a batch of wallets efficiently
   */
  private async processWalletsBatch(wallets: EnhancedWalletData[], category: string): Promise<void> {
    logger.info(`Processing batch of ${wallets.length} ${category} wallets`);

    // Group wallets into 10 or fewer at a time to avoid overwhelming the database
    const batchSize = 10;
    const batches = [];
    for (let i = 0; i < wallets.length; i += batchSize) {
      batches.push(wallets.slice(i, i + batchSize));
    }

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      logger.info(`Processing wallet batch ${i+1}/${batches.length} with ${batch.length} wallets`);

      // Process each wallet in the batch
      const promises = batch.map(async (wallet) => {
        try {
          // Check cache first
          const cacheKey = wallet.address;
          if (!cacheKey) return;
          
          const now = Date.now();
          const cached = this.walletCache.get(cacheKey);
          
          // If we have a recent cache hit, use it
          if (cached && (now - cached.timestamp) < this.config.dataCacheTTL) {
            logger.info(`Using cached data for wallet ${wallet.address}`);
            await this.saveWallet({...cached.data, category});
            return;
          }
          
          // Add category cross-reference
          this.trackWalletCategory(wallet.address, category);
          
          // ENHANCED: Predict success rate based on wallet metrics
          wallet.predictedSuccessRate = this.predictWalletSuccessRate(wallet);
          wallet.confidenceScore = this.calculateWalletConfidenceScore(wallet);
          
          // Save wallet to database
          await this.saveWallet(wallet);
          
          // Get and process transactions if this is a high-confidence wallet
          if (wallet.confidenceScore && wallet.confidenceScore > 70 && wallet.address) {
            await this.getWalletTransactions(wallet.address);
          }
          
          // Cache wallet data
          if (wallet.address) {
            this.walletCache.set(wallet.address, {
              data: wallet,
              timestamp: now
            });
          }
          
          this.stats.walletsProcessed++;
          
          // Add to known successful wallets if win rate is within target
          if (wallet.address && wallet.winRate && 
              wallet.winRate >= this.config.targetSuccessRate.min && 
              wallet.winRate <= this.config.targetSuccessRate.max) {
            this.knownSuccessfulWallets.add(wallet.address);
          }
        } catch (error) {
          logger.error(`Error processing wallet ${wallet.address}:`, error instanceof Error ? error.message : String(error));
        }
      });

      // Wait for all wallets in the batch to be processed
      await Promise.all(promises);
    }
  }

  /**
   * ENHANCED: Track wallet category for cross-referencing
   */
  private trackWalletCategory(address: string | undefined, category: string): void {
    if (!address) return;
    
    const categories = this.crossCategoryWallets.get(address) || [];
    if (!categories.includes(category)) {
      categories.push(category);
      this.crossCategoryWallets.set(address, categories);
    }
  }

  /**
   * ENHANCED: Identify wallets that appear in multiple categories
   */
  private identifyCrossCategoryWallets(): void {
    logger.info('Identifying cross-category wallets');

    const crossCategoryCount = {
      'Sniper,Gem Spotter': 0,
      'Sniper,Early Mover': 0,
      'Gem Spotter,Early Mover': 0,
      'Sniper,Gem Spotter,Early Mover': 0
    };)) {
                // PNL element
                analysis.pnlSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              } else if (className.includes('trade') || className.includes('tx') || 
                         className.includes('count')) {
                // Trades element
                analysis.tradesSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              } else if (className.includes('hold') || className.includes('time') || 
                         className.includes('duration')) {
                // Hold time element
                analysis.holdTimeSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              }
            });
          }
        });

        // 3. Check grid layouts
        grids.forEach((grid, gridIndex) => {
          const items = grid.querySelectorAll(':scope > *');
          if (items.length >= 3) {
            // This might be a grid of wallet cards
            analysis.containerSelectors.push(`${grid.tagName.toLowerCase()}${grid.className ? `.${grid.className.replace(/\s+/g, '.')}` : ''}:nth-of-type(${gridIndex + 1}) > *`);
            
            // Similar analysis as list items
            const firstItem = items[0];
            
            // Look for elements with class names or texts that suggest data types
            const elements = firstItem.querySelectorAll('*');
            elements.forEach((el) => {
              const className = el.className || '';
              const text = el.textContent?.toLowerCase() || '';
              
              if (className.includes('address') || className.includes('wallet') || 
                  className.includes('id') || text.includes('0x')) {
                // Address element
                analysis.addressSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              } else if (className.includes('win') || className.includes('rate') || 
                         className.includes('success') || text.includes('%')) {
                // Win rate element
                analysis.winRateSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              } else if (className.includes('pnl') || className.includes('profit') || 
                         text.includes('
        }

        console.log(`Found ${walletElements.length} wallet elements with selector: ${usedSelector}`);

        // Process each wallet element
        Array.from(walletElements).forEach((row, index) => {
          try {
            // Extract address with multiple approaches
            let address = '';
            
            // Try DOM analysis address columns
            for (const selector of domAnalysis.addressSelectors) {
              const addressElement = row.querySelector(selector);
              if (addressElement) {
                // Try text content first
                address = addressElement.textContent?.trim() || '';
                
                // If address looks truncated, try attributes
                if (address.includes('...')) {
                  address = addressElement.getAttribute('data-address') || 
                           addressElement.getAttribute('title') || 
                           addressElement.getAttribute('data-original') || 
                           address;
                }
                
                // If we found a valid address, break
                if (address && !address.includes('...')) {
                  break;
                }
              }
            }
            
            // If no address found, try extracting from generic elements
            if (!address || address.includes('...')) {
              const addressSelectors = [
                '.address', '.wallet-address', '[data-address]', '.address-text',
                'a[href*="wallet/"]', 'a[href*="address/"]', '[title*="0x"]',
                'td:nth-child(1)', '.address-column', '.wallet-id', '.trader-id'
              ];
              
              address = extractTextBySelectors(row, addressSelectors);
              
              // If address contains ellipsis, try to get from data attribute or title
              if (!address || address.includes('...')) {
                const addressEl = row.querySelector(addressSelectors.join(', '));
                if (addressEl) {
                  address = addressEl.getAttribute('data-address') || 
                           addressEl.getAttribute('title') || 
                           addressEl.getAttribute('data-original') || 
                           address;
                }
              }
              
              // Try to extract from href if nothing else worked
              if (!address || address.includes('...')) {
                const link = row.querySelector('a[href*="wallet/"], a[href*="address/"]');
                if (link) {
                  const href = link.getAttribute('href') || '';
                  const matches = href.match(/\/(wallet|address)\/([^/?#]+)/);
                  if (matches && matches[2]) {
                    address = matches[2];
                  }
                }
              }
            }
            
            // Skip if no valid address found
            if (!address || address.includes('...')) {
              console.warn(`Row ${index} skipped: Invalid address "${address}"`);
              return;
            }
            
            // Extract win rate with multiple approaches
            let winRateText = '';
            let winRate = 0;
            
            // Try DOM analysis win rate columns
            for (const selector of domAnalysis.winRateSelectors) {
              const winRateElement = row.querySelector(selector);
              if (winRateElement) {
                winRateText = winRateElement.textContent?.trim() || '';
                winRate = parseFloat(winRateText.replace(/%/g, '')) || 0;
                if (winRate > 0) {
                  break;
                }
              }
            }
            
            // If no win rate found, try generic selectors
            if (winRate === 0) {
              const winRateSelectors = [
                '.win-rate', '.success-rate', '[data-win-rate]', '.wr',
                '.win-percentage', 'td:nth-child(2)', '.win-rate-column',
                '.success-percentage', '.rate', '.win-pct'
              ];
              winRateText = extractTextBySelectors(row, winRateSelectors, '0%');
              winRate = parseFloat(winRateText.replace(/%/g, '')) || 0;
            }
            
            // Extract PNL with multiple approaches
            let pnlText = '';
            let totalPnL = 0;
            
            // Try DOM analysis PNL columns
            for (const selector of domAnalysis.pnlSelectors) {
              const pnlElement = row.querySelector(selector);
              if (pnlElement) {
                pnlText = pnlElement.textContent?.trim() || '';
                totalPnL = parseNumericValue(pnlText);
                if (totalPnL > 0) {
                  break;
                }
              }
            }
            
            // If no PNL found, try generic selectors
            if (totalPnL === 0) {
              const pnlSelectors = [
                '.pnl', '.profit', '[data-pnl]', '.profit-loss',
                '.earnings', 'td:nth-child(3)', '.pnl-column',
                '.total-profit', '.net-profit', '.p-n-l'
              ];
              pnlText = extractTextBySelectors(row, pnlSelectors, '$0');
              totalPnL = parseNumericValue(pnlText);
            }
            
            // Extract trades with multiple approaches
            let tradesText = '';
            let successfulTrades = 0;
            let totalTrades = 0;
            
            // Try DOM analysis trades columns
            for (const selector of domAnalysis.tradesSelectors) {
              const tradesElement = row.querySelector(selector);
              if (tradesElement) {
                tradesText = tradesElement.textContent?.trim() || '';
                
                // Handle different formats
                if (tradesText) {
                  if (tradesText.includes('/')) {
                    // Format like "225/646"
                    const parts = tradesText.split('/');
                    successfulTrades = parseInt(parts[0].trim()) || 0;
                    totalTrades = parseInt(parts[1].trim()) || 0;
                  } else {
                    // Just total trades
                    totalTrades = parseInt(tradesText.replace(/[^0-9]/g, '')) || 0;
                    // Estimate successful trades based on win rate
                    successfulTrades = Math.round(totalTrades * (winRate / 100));
                  }
                  
                  if (totalTrades > 0) {
                    break;
                  }
                }
              }
            }
            
            // If no trades found, try generic selectors
            if (totalTrades === 0) {
              const tradesSelectors = [
                '.trades', '.trade-count', '[data-trades]', '.transactions',
                '.tx-count', 'td:nth-child(4)', '.trades-column',
                '.number-of-trades', '.total-trades'
              ];
              tradesText = extractTextBySelectors(row, tradesSelectors, '0/0');
              
              if (tradesText.includes('/')) {
                // Format like "225/646"
                const parts = tradesText.split('/');
                successfulTrades = parseInt(parts[0].trim()) || 0;
                totalTrades = parseInt(parts[1].trim()) || 0;
              } else {
                // Just total trades
                totalTrades = parseInt(tradesText.replace(/[^0-9]/g, '')) || 0;
                // Estimate successful trades based on win rate
                successfulTrades = Math.round(totalTrades * (winRate / 100));
              }
            }
            
            // Extract hold time with multiple approaches
            let avgHoldTime = '';
            
            // Try DOM analysis hold time columns
            for (const selector of domAnalysis.holdTimeSelectors) {
              const holdTimeElement = row.querySelector(selector);
              if (holdTimeElement) {
                avgHoldTime = holdTimeElement.textContent?.trim() || '';
                if (avgHoldTime) {
                  break;
                }
              }
            }
            
            // If no hold time found, try generic selectors
            if (!avgHoldTime) {
              const holdTimeSelectors = [
                '.hold-time', '.avg-hold', '[data-hold-time]', '.duration',
                '.holding-period', 'td:nth-child(5)', '.hold-time-column',
                '.average-hold-time', '.avg-duration'
              ];
              avgHoldTime = extractTextBySelectors(row, holdTimeSelectors, '');
            }
            
            // Extract any other useful metrics if available
            
            // 4x consistency (if available)
            let returns4xConsistency = 0;
            const returns4xSelectors = [
              '.returns-4x', '.x4-rate', '[data-4x-rate]', '.x4-percentage',
              '.multiplier-rate', '.high-returns-rate'
            ];
            const returns4xText = extractTextBySelectors(row, returns4xSelectors);
            if (returns4xText) {
              returns4xConsistency = parseFloat(returns4xText.replace(/%/g, '')) || 0;
            }
            
            // Add wallet to results if it has valid data
            if (address && (winRate > 0 || totalPnL > 0)) {
              wallets.push({
                address,
                network: 'solana', // Default to Solana
                category,
                winRate,
                totalPnL,
                successfulTrades,
                totalTrades,
                avgHoldTime,
                isActive: true,
                lastUpdated: new Date(),
                returns4xConsistency,
                // Add metadata for enhanced analysis
                metadata: {
                  tradingFrequency: 
                    totalTrades >= 500 ? 'Very High' : 
                    totalTrades >= 200 ? 'High' : 
                    totalTrades >= 50 ? 'Medium' : 
                    totalTrades >= 10 ? 'Low' : 'Very Low'
                }
              });
            }
          } catch (error) {
            console.error(`Error parsing wallet row ${index}:`, error);
          }
        });

        return wallets;import puppeteer from 'puppeteer';
import { logger } from '../utils/logger';
import path from 'path';
import fs from 'fs';
import { ExternalWallet, IExternalWallet } from '../models/externalWallet';
import { connectToDatabase } from '../utils/database';
import { ClassifiedTransaction, EnhancedWalletData } from '../types/wallet';
import config from '../config';

// Scraper configuration type
interface ChainEDGEConfig {
  baseUrl: string;
  username: string;
  password: string;
  minWinRate: number;
  minPnL: number;
  minTrades: number;
  minTokensTraded: number;
  minBuyValue: number;
  scrapeInterval: number; // in milliseconds
  walletCategories: {
    sniper: boolean;
    gemSpotter: boolean;
    earlyMover: boolean;
  };
  timeframeFilters: {
    fastTimeframe: boolean; // 1-4 hour trades
    slowTimeframe: boolean; // 4-48 hour trades
  };
  // New optimization parameters
  targetSuccessRate: {
    min: number; // Minimum target success rate (e.g., 74)
    max: number; // Maximum target success rate (e.g., 76)
  };
  dataCacheTTL: number; // Cache time-to-live in milliseconds
  parallelProcessing: boolean; // Enable parallel processing
  maxRetries: number; // Maximum number of retries for failed operations
  retryDelay: number; // Initial delay between retries in milliseconds
  cacheDirectory: string; // Directory to store cache files
  adaptiveThresholds: boolean; // Dynamically adjust thresholds based on results
}

// Time-specific success metrics interface
interface TimeframeMetrics {
  totalTrades: number;
  successfulTrades: number;
  winRate: number;
  avgMultiplier: number;
  avgHoldTime: number; // in minutes
}

// Transaction with timeframe classification
interface ClassifiedTransaction extends IWalletTransaction {
  timeframe: 'fast' | 'slow' | 'other';
  holdTimeMinutes: number;
  multiplier: number;
  meta?: {
    timeframeSuccessRate?: number;
    isMemeToken?: boolean;
    entryTimingScore?: number;
  };
}

// Enhanced wallet data with timeframe-specific metrics
interface EnhancedWalletData extends Partial<IExternalWallet> {
  fastTimeframeMetrics?: TimeframeMetrics;
  slowTimeframeMetrics?: TimeframeMetrics;
  memeTokenMetrics?: {
    totalTrades: number;
    successfulTrades: number;
    winRate: number;
    avgMultiplier: number;
  };
  patternSuccessRates?: Record<string, number>;
  entryTiming?: number; // How early they typically get in (percentile)
  exitEfficiency?: number; // How close to top they typically exit (percentile)
  recentTransactions?: ClassifiedTransaction[];
  // New fields for success rate prediction
  predictedSuccessRate?: number;
  confidenceScore?: number; // How confident we are in the data quality
  categoryCrossover?: string[]; // Categories this wallet appears in
  returns4xConsistency?: number; // Consistency score for 4x returns
}

// Interface for selector history tracking
interface SelectorHistory {
  selector: string;
  successCount: number;
  failCount: number;
  lastSuccess: Date | null;
  lastFail: Date | null;
}

// Interface for tracking scraping jobs
interface ScrapingJobStats {
  startTime: Date;
  endTime: Date | null;
  category: string;
  walletsFound: number;
  highQualityWallets: number;
  errors: string[];
  success: boolean;
  currentSuccessRate: number | null;
}

export class ChainEDGEScraper {
  private browser: puppeteer.Browser | null = null;
  private page: puppeteer.Page | null = null;
  private config: ChainEDGEConfig;
  private isLoggedIn = false;
  private isRunning = false;
  private stats = {
    totalWalletsSeen: 0,
    walletsProcessed: 0,
    transactionsProcessed: 0,
    highValueWallets: 0,
    scrapingJobs: [] as ScrapingJobStats[],
    lastSuccessRate: null as number | null,
    adaptiveThresholdAdjustments: 0
  };

  // New fields for enhanced functionality
  private selectorHistory: Record<string, Record<string, SelectorHistory>> = {};
  private walletCache: Map<string, { data: EnhancedWalletData, timestamp: number }> = new Map();
  private knownSuccessfulWallets: Set<string> = new Set();
  private activeScrapingJobs: number = 0;
  private categorySuccessRates: Record<string, number> = {
    'Sniper': 0,
    'Gem Spotter': 0,
    'Early Mover': 0
  };
  private crossCategoryWallets: Map<string, string[]> = new Map();

  constructor(config?: Partial<ChainEDGEConfig>) {
    // Default configuration with values optimized for meme coin detection
    this.config = {
      baseUrl: config?.baseUrl || 'https://app.chainedge.io',
      username: config?.username || process.env.CHAINEDGE_USERNAME || '',
      password: config?.password || process.env.CHAINEDGE_PASSWORD || '',
      minWinRate: config?.minWinRate || 75, // Targeting high win rate for 74-76% success goal
      minPnL: config?.minPnL || 50000, // Minimum $50k profit to ensure quality
      minTrades: config?.minTrades || 30, // Statistically significant number
      minTokensTraded: config?.minTokensTraded || 10, // Ensure diverse trading history
      minBuyValue: config?.minBuyValue || 500, // Minimum buy value to filter out small trades
      scrapeInterval: config?.scrapeInterval || 3600000, // Default 1 hour
      walletCategories: {
        sniper: config?.walletCategories?.sniper !== undefined ? config.walletCategories.sniper : true,
        gemSpotter: config?.walletCategories?.gemSpotter !== undefined ? config.walletCategories.gemSpotter : true,
        earlyMover: config?.walletCategories?.earlyMover !== undefined ? config.walletCategories.earlyMover : true,
      },
      timeframeFilters: {
        fastTimeframe: config?.timeframeFilters?.fastTimeframe !== undefined ? config.timeframeFilters.fastTimeframe : true,
        slowTimeframe: config?.timeframeFilters?.slowTimeframe !== undefined ? config.timeframeFilters.slowTimeframe : true,
      },
      // New optimization parameters
      targetSuccessRate: {
        min: config?.targetSuccessRate?.min || 74,
        max: config?.targetSuccessRate?.max || 76
      },
      dataCacheTTL: config?.dataCacheTTL || 24 * 60 * 60 * 1000, // 24 hours by default
      parallelProcessing: config?.parallelProcessing || false, // Default to false for stability
      maxRetries: config?.maxRetries || 3,
      retryDelay: config?.retryDelay || 1000,
      cacheDirectory: config?.cacheDirectory || path.join(process.cwd(), 'cache'),
      adaptiveThresholds: config?.adaptiveThresholds !== undefined ? config.adaptiveThresholds : true
    };

    // Create cache directory if it doesn't exist
    if (!fs.existsSync(this.config.cacheDirectory)) {
      fs.mkdirSync(this.config.cacheDirectory, { recursive: true });
    }

    // Initialize selector history for categories
    const categories = ['Sniper', 'Gem Spotter', 'Early Mover'];
    const selectorTypes = [
      'categoryButton', 'filterButton', 'winRateInput', 
      'pnlInput', 'tradesInput', 'submitButton'
    ];

    categories.forEach(category => {
      this.selectorHistory[category] = {};
      selectorTypes.forEach(type => {
        this.selectorHistory[category][type] = {
          selector: '',
          successCount: 0,
          failCount: 0,
          lastSuccess: null,
          lastFail: null
        };
      });
    });

    // Load cached wallet data if available
    this.loadWalletCache();

    // Validate config
    this.validateConfig();
  }

  /**
   * Get current configuration
   */
  getConfig(): ChainEDGEConfig {
    return this.config;
  }

  /**
   * Validate configuration parameters
   */
  private validateConfig(): void {
    if (!this.config.username || !this.config.password) {
      throw new Error('ChainEDGE username and password are required');
    }

    // At least one wallet category must be enabled
    if (!this.config.walletCategories.sniper && 
        !this.config.walletCategories.gemSpotter && 
        !this.config.walletCategories.earlyMover) {
      throw new Error('At least one wallet category must be enabled');
    }

    // At least one timeframe filter must be enabled
    if (!this.config.timeframeFilters.fastTimeframe && 
        !this.config.timeframeFilters.slowTimeframe) {
      throw new Error('At least one timeframe filter must be enabled');
    }

    // Validate target success rate
    if (this.config.targetSuccessRate.min < 0 || 
        this.config.targetSuccessRate.max > 100 ||
        this.config.targetSuccessRate.min > this.config.targetSuccessRate.max) {
      throw new Error('Invalid target success rate range');
    }
  }

  /**
   * Initialize the scraper
   */
  async initialize(): Promise<boolean> {
    try {
      logger.info('Initializing ChainEDGE scraper');

      // Launch browser with stealth mode for better detection avoidance
      this.browser = await puppeteer.launch({
        headless: false, // Change to false to see the browser in action
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--disable-infobars',
          '--window-size=1920,1080',
          '--disable-gpu',
          '--disable-extensions'
        ],
        ignoreHTTPSErrors: true
      });

      // Create a new page
      this.page = await this.browser.newPage();

      // Set user agent to avoid detection
      await this.page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36');

      // Set viewport size
      await this.page.setViewport({ width: 1920, height: 1080 });

      // Enable stealth mode
      await this.page.evaluateOnNewDocument(() => {
        // Hide webdriver
        Object.defineProperty(navigator, 'webdriver', {
          get: () => false
        });

        // Hide Chrome
        window.navigator.chrome = {
          runtime: {} as any
        };

        // Hide Automation
        window.navigator.languages = ['en-US', 'en'];

        // Overwrite permissions
        const originalQuery = window.navigator.permissions.query;
        window.navigator.permissions.query = (parameters: any) => {
          return (parameters.name === 'notifications' 
            ? Promise.resolve({ state: Notification.permission }) 
            : originalQuery(parameters)) as any;
        };
      });

      // Log in to ChainEDGE
      await this.login();

      logger.info('ChainEDGE scraper initialized successfully');
      return true;
    } catch (error) {
      logger.error('Failed to initialize ChainEDGE scraper:', error instanceof Error ? error.message : String(error));
      await this.cleanup();
      return false;
    }
  }

  /**
   * Log in to ChainEDGE
   */
  private async login(): Promise<void> {
    if (!this.page) {
      throw new Error('Browser not initialized');
    }

    try {
      logger.info('Logging in to ChainEDGE');

      // Navigate to the login page with next parameter
      await this.page.goto(`${this.config.baseUrl}/login/?next=/`, {
        waitUntil: 'networkidle2',
        timeout: 60000
      });

      // Take screenshot for debugging
      await this.page.screenshot({ path: 'login-page.png' });
      logger.info('Saved login page screenshot to login-page.png');

      // Wait for login form to load - add more selector variations
      await this.page.waitForSelector('input[type="email"], input[name="email"], input#email, input[placeholder*="Email"], input[placeholder*="email"]', { timeout: 10000 });

      // Add delay to ensure page is ready
      await this.page.waitForTimeout(1000);

      // Fill in login form - adjust selectors as needed
      const emailSelector = 'input[type="email"], input[name="email"], input#email, input[placeholder*="Email"], input[placeholder*="email"]';
      await this.page.type(emailSelector, this.config.username);

      const passwordSelector = 'input[type="password"], input[name="password"], input#password, input[placeholder*="Password"], input[placeholder*="password"]';
      await this.page.type(passwordSelector, this.config.password);

      // Add delay before clicking
      await this.page.waitForTimeout(1000);

      // Click login button with more options
      const loginButtonSelector = 'button[type="submit"], button:contains("Sign In"), button:contains("Login"), button.login-button, input[type="submit"]';

      // Take screenshot before clicking login
      await this.page.screenshot({ path: 'before-login-click.png' });

      await Promise.all([
        this.page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 60000 }).catch(() => {
          logger.warn('Navigation timeout after login attempt - continuing anyway');
        }),
        this.page.click(loginButtonSelector)
      ]);

      // Add extra wait time for potential redirects after login
      await this.page.waitForTimeout(5000);

      // Take screenshot after login attempt
      await this.page.screenshot({ path: 'after-login.png' });

      // Check if login was successful - updated for more potential dashboard elements
      const isLoggedIn = await this.page.evaluate(() => {
        // Look for elements that would indicate successful login
        return !document.querySelector('input[type="password"]') && 
               (document.querySelector('.user-profile, .dashboard, .nav-dashboard, .logged-in, .account-info, .user-menu, .profile-section') !== null);
      });

      if (!isLoggedIn) {
        // Take screenshot of the failed login page
        await this.page.screenshot({ path: 'login-failed.png' });
        throw new Error('Login failed - could not verify successful login. See login-failed.png');
      }

      this.isLoggedIn = true;
      logger.info('Successfully logged in to ChainEDGE');
    } catch (error) {
      logger.error('Failed to log in to ChainEDGE:', error instanceof Error ? error.message : String(error));
      throw new Error(`Authentication failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Start scheduled scraping
   */
  async startScheduledScraping(): Promise<void> {
    if (this.isRunning) {
      logger.warn('Scraper is already running');
      return;
    }

    try {
      this.isRunning = true;

      // Initial scrape
      await this.scrapeWallets();

      // Set up interval for recurring scrapes
      setInterval(async () => {
        if (!this.isRunning) return;

        try {
          // Only run if no active scraping jobs
          if (this.activeScrapingJobs === 0) {
            await this.scrapeWallets();
          } else {
            logger.warn(`Skipping scheduled scrape - ${this.activeScrapingJobs} active scraping jobs`);
          }
        } catch (error) {
          logger.error('Error in scheduled scrape:', error instanceof Error ? error.message : String(error));
          
          // Try to reinitialize if needed
          if (!this.isLoggedIn || !this.page) {
            logger.info('Attempting to reinitialize scraper...');
            await this.initialize();
          }
        }
      }, this.config.scrapeInterval);

      logger.info(`Scheduled scraping started with ${this.config.scrapeInterval / 60000} minute interval`);
    } catch (error) {
      this.isRunning = false;
      logger.error('Failed to start scheduled scraping:', error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * Stop scheduled scraping
   */
  async stopScheduledScraping(): Promise<void> {
    this.isRunning = false;
    logger.info('Scheduled scraping stopped');
  }

  /**
   * Scrape wallet data from ChainEDGE
   */
  async scrapeWallets(): Promise<void> {
    if (!this.isLoggedIn || !this.page) {
      await this.initialize();
    }

    try {
      logger.info('Starting to scrape wallet data from ChainEDGE');

      // Get enabled wallet categories
      const categories: string[] = [];
      if (this.config.walletCategories.sniper) categories.push('Sniper');
      if (this.config.walletCategories.gemSpotter) categories.push('Gem Spotter');
      if (this.config.walletCategories.earlyMover) categories.push('Early Mover');

      // Process each category
      if (this.config.parallelProcessing) {
        // Process categories in parallel
        await Promise.all(categories.map(category => this.scrapeWalletsByCategory(category)));
      } else {
        // Process categories sequentially
        for (const category of categories) {
          await this.scrapeWalletsByCategory(category);
        }
      }

      // After all categories are processed, check for wallets appearing in multiple categories
      this.identifyCrossCategoryWallets();

      // Adjust thresholds if adaptive thresholds are enabled
      if (this.config.adaptiveThresholds) {
        await this.adjustThresholdsBasedOnResults();
      }

      // Save wallet cache
      this.saveWalletCache();

      logger.info(`Wallet data scraping completed. Stats: ${JSON.stringify(this.stats)}`);
    } catch (error) {
      logger.error('Error scraping wallet data:', error instanceof Error ? error.message : String(error));
      throw error;
    }
  }

  /**
   * ENHANCED: Scrape wallets for a specific category with improved resilience and accuracy
   */
  private async scrapeWalletsByCategory(category: string): Promise<void> {
    if (!this.page) return;

    // Track job stats
    const jobStats: ScrapingJobStats = {
      startTime: new Date(),
      endTime: null,
      category,
      walletsFound: 0,
      highQualityWallets: 0,
      errors: [],
      success: false,
      currentSuccessRate: null
    };

    this.activeScrapingJobs++;
    this.stats.scrapingJobs.push(jobStats);

    try {
      logger.info(`Scraping ${category} wallets`);

      let retryCount = 0;
      let success = false;

      // Retry loop with exponential backoff
      while (!success && retryCount < this.config.maxRetries) {
        try {
          // If retry, wait with exponential backoff
          if (retryCount > 0) {
            const delay = this.config.retryDelay * Math.pow(2, retryCount - 1);
            logger.info(`Retry ${retryCount}/${this.config.maxRetries} for ${category} after ${delay}ms`);
            await this.page.waitForTimeout(delay);
          }
          
          // Navigate to main dashboard page
          await this.page.goto(`${this.config.baseUrl}/dashboard`, { 
            waitUntil: 'networkidle2',
            timeout: 60000
          });
          
          // Take a screenshot of the dashboard for debugging
          const screenshotPath = `dashboard-${category}-${new Date().toISOString().replace(/:/g, '-')}.png`;
          await this.page.screenshot({ path: screenshotPath });
          logger.info(`Saved dashboard screenshot to ${screenshotPath}`);
          
          // Verify we're on the dashboard page
          const onDashboard = await this.verifyCurrentPage('dashboard');
          if (!onDashboard) {
            throw new Error('Not on dashboard page');
          }
          
          // Wait for the page to fully load with adaptive selector strategy
          const contentSelector = await this.findWorkingSelector([
            '.content', '.dashboard', '.main-content', '.container', 
            '.filter-button', '.category-filter', '[data-category]',
            // Add structure-based selectors that are less likely to change
            'div[class*="dashboard"]', 'div[class*="content"]', 'main', 'div[role="main"]'
          ], 'dashboardContent');
          
          if (!contentSelector) {
            throw new Error('Could not find dashboard content');
          }
          
          await this.page.waitForSelector(contentSelector, { timeout: 15000 }).catch(() => {
            logger.warn('Could not find expected dashboard elements - continuing anyway');
          });
          
          // Wait for a moment to ensure the dashboard is fully loaded
          await this.page.waitForTimeout(3000);
          
          // ENHANCED: Use adaptive selector system to find category filter elements
          const filterResult = await this.findAndClickCategoryFilter(category);
          if (!filterResult.success) {
            throw new Error(`Could not select ${category} filter: ${filterResult.reason}`);
          }
          
          // Wait for results to load
          await this.page.waitForTimeout(2000);
          
          // Take screenshot after category selection
          await this.page.screenshot({ path: `after-category-selection-${category}.png` });
          
          // ENHANCED: Use adaptive selector system to find and click filter button
          const filterButtonResult = await this.findAndClickFilterButton();
          if (!filterButtonResult.success) {
            throw new Error(`Could not click filter button: ${filterButtonResult.reason}`);
          }
          
          // Wait for filter dialog to appear with adaptive selector strategy
          await this.page.waitForSelector('input, form, .filter-form, .modal', { timeout: 15000 }).catch(() => {
            logger.warn('Could not find filter form elements - continuing anyway');
          });
          
          // Take screenshot of filter dialog
          await this.page.screenshot({ path: `filter-dialog-${category}.png` });
          
          // ENHANCED: Adaptively fill filter form with optimized values based on target success rate
          const filledFields = await this.fillFilterForm(category);
          logger.info(`Filter fields filled: ${filledFields.join(', ')}`);
          
          // Take screenshot after filling the filter form
          await this.page.screenshot({ path: `filter-form-filled-${category}.png` });
          
          // ENHANCED: Submit the filter form with adaptive selector system
          const submitResult = await this.submitFilterForm();
          if (!submitResult.success) {
            throw new Error(`Could not submit filter form: ${submitResult.reason}`);
          }
          
          // Wait for results to load with random delay to avoid detection
          const randomWait = 2000 + Math.random() * 1000;
          await this.page.waitForTimeout(randomWait);
          
          // Take screenshot of results
          await this.page.screenshot({ path: `results-${category}.png` });
          
          // ENHANCED: Extract wallet data with improved robustness
          const wallets = await this.extractWalletData(category);
          this.stats.totalWalletsSeen += wallets.length;
          jobStats.walletsFound = wallets.length;
          
          logger.info(`Found ${wallets.length} ${category} wallets`);
          
          // ENHANCED: Apply dynamic filtering based on target success rate
          const highQualityWallets = await this.filterHighQualityWallets(wallets, category);
          this.stats.highValueWallets += highQualityWallets.length;
          jobStats.highQualityWallets = highQualityWallets.length;
          
          logger.info(`Found ${highQualityWallets.length} high quality ${category} wallets`);
          
          // ENHANCED: Process wallets with success prediction and cross-referencing
          await this.processWalletsBatch(highQualityWallets, category);
          
          // Mark success
          success = true;
          
          // Update category success rate
          const processedWallets = await ExternalWallet.find({ category });
          if (processedWallets.length > 0) {
            const successRateSum = processedWallets.reduce((sum, wallet) => sum + wallet.winRate, 0);
            this.categorySuccessRates[category] = successRateSum / processedWallets.length;
            jobStats.currentSuccessRate = this.categorySuccessRates[category];
          }
          
          logger.info(`Processed ${highQualityWallets.length} ${category} wallets with estimated success rate: ${this.categorySuccessRates[category].toFixed(2)}%`);
        } catch (error) {
          retryCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger.error(`Error (attempt ${retryCount}/${this.config.maxRetries}) scraping ${category} wallets: ${errorMessage}`);
          
          // If we still have retries, take a screenshot and continue
          if (retryCount < this.config.maxRetries) {
            await this.page.screenshot({ path: `error-${category}-retry${retryCount}.png` });
          } else {
            // Log the error to job stats
            jobStats.errors.push(errorMessage);
            throw error; // Re-throw to be caught by outer try-catch
          }
        }
      }

      // If we exit the loop successfully
      if (success) {
        jobStats.success = true;
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to scrape ${category} wallets after ${this.config.maxRetries} attempts: ${errorMessage}`);
      jobStats.errors.push(errorMessage);
    } finally {
      // Update job stats
      jobStats.endTime = new Date();
      this.activeScrapingJobs--;
    }
  }

  /**
   * ENHANCED: Process a batch of wallets efficiently
   */
  private async processWalletsBatch(wallets: EnhancedWalletData[], category: string): Promise<void> {
    logger.info(`Processing batch of ${wallets.length} ${category} wallets`);

    // Group wallets into 10 or fewer at a time to avoid overwhelming the database
    const batchSize = 10;
    const batches = [];
    for (let i = 0; i < wallets.length; i += batchSize) {
      batches.push(wallets.slice(i, i + batchSize));
    }

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      logger.info(`Processing wallet batch ${i+1}/${batches.length} with ${batch.length} wallets`);

      // Process each wallet in the batch
      const promises = batch.map(async (wallet) => {
        try {
          // Check cache first
          const cacheKey = wallet.address;
          if (!cacheKey) return;
          
          const now = Date.now();
          const cached = this.walletCache.get(cacheKey);
          
          // If we have a recent cache hit, use it
          if (cached && (now - cached.timestamp) < this.config.dataCacheTTL) {
            logger.info(`Using cached data for wallet ${wallet.address}`);
            await this.saveWallet({...cached.data, category});
            return;
          }
          
          // Add category cross-reference
          this.trackWalletCategory(wallet.address, category);
          
          // ENHANCED: Predict success rate based on wallet metrics
          wallet.predictedSuccessRate = this.predictWalletSuccessRate(wallet);
          wallet.confidenceScore = this.calculateWalletConfidenceScore(wallet);
          
          // Save wallet to database
          await this.saveWallet(wallet);
          
          // Get and process transactions if this is a high-confidence wallet
          if (wallet.confidenceScore && wallet.confidenceScore > 70 && wallet.address) {
            await this.getWalletTransactions(wallet.address);
          }
          
          // Cache wallet data
          if (wallet.address) {
            this.walletCache.set(wallet.address, {
              data: wallet,
              timestamp: now
            });
          }
          
          this.stats.walletsProcessed++;
          
          // Add to known successful wallets if win rate is within target
          if (wallet.address && wallet.winRate && 
              wallet.winRate >= this.config.targetSuccessRate.min && 
              wallet.winRate <= this.config.targetSuccessRate.max) {
            this.knownSuccessfulWallets.add(wallet.address);
          }
        } catch (error) {
          logger.error(`Error processing wallet ${wallet.address}:`, error instanceof Error ? error.message : String(error));
        }
      });

      // Wait for all wallets in the batch to be processed
      await Promise.all(promises);
    }
  }

  /**
   * ENHANCED: Track wallet category for cross-referencing
   */
  private trackWalletCategory(address: string | undefined, category: string): void {
    if (!address) return;
    
    const categories = this.crossCategoryWallets.get(address) || [];
    if (!categories.includes(category)) {
      categories.push(category);
      this.crossCategoryWallets.set(address, categories);
    }
  }

  /**
   * ENHANCED: Identify wallets that appear in multiple categories
   */
  private identifyCrossCategoryWallets(): void {
    logger.info('Identifying cross-category wallets');

    const crossCategoryCount = {
      'Sniper,Gem Spotter': 0,
      'Sniper,Early Mover': 0,
      'Gem Spotter,Early Mover': 0,
      'Sniper,Gem Spotter,Early Mover':)) {
                // PNL element
                analysis.pnlSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              } else if (className.includes('trade') || className.includes('tx') || 
                         className.includes('count')) {
                // Trades element
                analysis.tradesSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              } else if (className.includes('hold') || className.includes('time') || 
                         className.includes('duration')) {
                // Hold time element
                analysis.holdTimeSelectors.push(`.${className.replace(/\s+/g, '.')}`);
              }
            });
          }
        });

        // Fallback to common selectors if nothing was found
        if (analysis.containerSelectors.length === 0) {
          analysis.containerSelectors = [
            'table tbody tr',
            '.wallet-row',
            '.trader-row',
            '.wallet-item',
            '.trader-item',
            '.wallet-card',
            '.data-row',
            '.list-item'
          ];
        }

        return analysis;
      });
    } catch (error) {
      logger.error('Error analyzing DOM for wallet data:', error instanceof Error ? error.message : String(error));

      // Return default selectors if analysis fails
      return {
        containerSelectors: [
          'table tbody tr',
          '.wallet-row',
          '.trader-row',
          '.wallet-item',
          '.trader-item',
          '.wallet-card',
          '.data-row',
          '.list-item'
        ],
        addressSelectors: [
          '.address', '.wallet-address', '[data-address]', '.address-text',
          'a[href*="wallet/"]', 'a[href*="address/"]', '[title*="0x"]',
          'td:nth-child(1)', '.address-column'
        ],
        winRateSelectors: [
          '.win-rate', '.success-rate', '[data-win-rate]', '.wr',
          '.win-percentage', 'td:nth-child(2)', '.win-rate-column'
        ],
        pnlSelectors: [
          '.pnl', '.profit', '[data-pnl]', '.profit-loss',
          '.earnings', 'td:nth-child(3)', '.pnl-column'
        ],
        tradesSelectors: [
          '.trades', '.trade-count', '[data-trades]', '.transactions',
          '.tx-count', 'td:nth-child(4)', '.trades-column'
        ],
        holdTimeSelectors: [
          '.hold-time', '.avg-hold', '[data-hold-time]', '.duration',
          '.holding-period', 'td:nth-child(5)', '.hold-time-column'
        ]
      };
    }
  }

  /**
   * ENHANCED: Fallback extraction method if DOM analysis fails
   */
  private async fallbackExtractWalletData(category: string): Promise<EnhancedWalletData[]> {
    if (!this.page) return [];

    logger.info(`Using fallback extraction method for ${category}`);

    return await this.page.evaluate((category) => {
      const wallets: any[] = [];

      // Function to extract text by trying multiple selectors
      const extractTextBySelectors = (element: Element, selectors: string[], defaultValue: string = ''): string => {
        for (const selector of selectors) {
          try {
            const el = element.querySelector(selector);
            if (el && el.textContent) {
              return el.textContent.trim();
            }
          } catch (e) {
            // Ignore errors and try next selector
          }
        }
        return defaultValue;
      };

      // Function to parse numeric values from strings with K/M suffixes
      const parseNumericValue = (text: string): number => {
        if (!text) return 0;
        
        const cleanText = text.replace(/[$,%]/g, '').trim();
        
        if (cleanText.includes('K') || cleanText.includes('k')) {
          return parseFloat(cleanText.replace(/[Kk]/g, '')) * 1000;
        } else if (cleanText.includes('M') || cleanText.includes('m')) {
          return parseFloat(cleanText.replace(/[Mm]/g, '')) * 1000000;
        } else {
          return parseFloat(cleanText) || 0;
        }
      };

      // Try different possible table/list selectors
      const containerSelectors = [
        'table tbody tr',
        '.wallet-row',
        '.trader-row',
        '.wallet-item',
        '.trader-item',
        '.wallet-card',
        '.data-row',
        '.user-row',
        '.list-item'
      ];

      let walletElements: NodeListOf<Element> | null = null;
      let usedSelector = '';

      // Try each selector until we find wallet elements
      for (const selector of containerSelectors) {
        const elements = document.querySelectorAll(selector);
        if (elements && elements.length > 0) {
          walletElements = elements;
          usedSelector = selector;
          break;
        }
      }

      // If no elements found with container selectors, try a more generic approach
      if (!walletElements || walletElements.length === 0) {
        console.warn('No wallet elements found with container selectors, trying generic approach');
        
        // Look for any table rows or grid items
        walletElements = document.querySelectorAll('tr, .grid > div, .list > div');
        usedSelector = 'generic';
      }

      if (!walletElements || walletElements.length === 0) {
        console.warn('No wallet elements found with any selector');
        return wallets;
      }

      console.log(`Found ${walletElements.length} wallet elements with selector: ${usedSelector}`);

      // Process each wallet element
      Array.from(walletElements).forEach((row, index) => {
        try {
          // Extract address - try multiple approaches
          const addressSelectors = [
            '.address', '.wallet-address', '[data-address]', '.address-text',
            'a[href*="wallet/"]', 'a[href*="address/"]', '[title*="0x"]',
            'td:nth-child(1)', '.address-column'
          ];
          
          let address = extractTextBySelectors(row, addressSelectors);
          
          // If address contains ellipsis, try to get from data attribute or title
          if (!address || address.includes('...')) {
            const addressEl = row.querySelector(addressSelectors.join(', '));
            if (addressEl) {
              address = addressEl.getAttribute('data-address') || 
                       addressEl.getAttribute('title') || 
                       addressEl.getAttribute('data-original') || 
                       address;
            }
          }
          
          // Skip if no valid address found
          if (!address || address.includes('...')) {
            console.warn(`Row ${index} skipped: Invalid address "${address}"`);
            return;
          }
          
          // Extract win rate
          const winRateSelectors = [
            '.win-rate', '.success-rate', '[data-win-rate]', '.wr',
            '.win-percentage', 'td:nth-child(2)', '.win-rate-column'
          ];
          const winRateText = extractTextBySelectors(row, winRateSelectors, '0%');
          const winRate = parseFloat(winRateText.replace(/%/g, '')) || 0;
          
          // Extract PNL
          const pnlSelectors = [
            '.pnl', '.profit', '[data-pnl]', '.profit-loss',
            '.earnings', 'td:nth-child(3)', '.pnl-column'
          ];
          const pnlText = extractTextBySelectors(row, pnlSelectors, '$0');
          const totalPnL = parseNumericValue(pnlText);
          
          // Extract trades
          const tradesSelectors = [
            '.trades', '.trade-count', '[data-trades]', '.transactions',
            '.tx-count', 'td:nth-child(4)', '.trades-column'
          ];
          const tradesText = extractTextBySelectors(row, tradesSelectors, '0/0');
          
          let successfulTrades = 0;
          let totalTrades = 0;
          
          // Handle different trade count formats
          if (tradesText.includes('/')) {
            // Format like "225/646"
            const parts = tradesText.split('/');
            successfulTrades = parseInt(parts[0].trim()) || 0;
            totalTrades = parseInt(parts[1].trim()) || 0;
          } else {
            // Just total trades
            totalTrades = parseInt(tradesText.replace(/[^0-9]/g, '')) || 0;
            // Estimate successful trades based on win rate
            successfulTrades = Math.round(totalTrades * (winRate / 100));
          }
          
          // Extract hold time
          const holdTimeSelectors = [
            '.hold-time', '.avg-hold', '[data-hold-time]', '.duration',
            '.holding-period', 'td:nth-child(5)', '.hold-time-column'
          ];
          const avgHoldTime = extractTextBySelectors(row, holdTimeSelectors, '');
          
          // Add wallet to results if it has valid data
          if (address && (winRate > 0 || totalPnL > 0)) {
            wallets.push({
              address,
              network: 'solana', // Adjust if ChainEDGE shows different networks
              category,
              winRate,
              totalPnL,
              successfulTrades,
              totalTrades,
              avgHoldTime,
              isActive: true,
              lastUpdated: new Date()
            });
          }
        } catch (error) {
          console.error(`Error parsing wallet row ${index}:`, error);
        }
      });

      return wallets;
    }, category);
  }

  /**
   * ENHANCED: Filter wallets with dynamic thresholds targeting 74-76% success rate
   */
  private async filterHighQualityWallets(wallets: EnhancedWalletData[], category: string): Promise<EnhancedWalletData[]> {
    // Get optimized thresholds for this category
    const thresholds = this.getOptimizedThresholds(category);

    // Add cross-category information to wallets
    wallets.forEach(wallet => {
      if (wallet.address) {
        const categories = this.crossCategoryWallets.get(wallet.address) || [];
        if (categories.length > 0 && !categories.includes(category)) {
          categories.push(category);
          this.crossCategoryWallets.set(wallet.address, categories);
        }
      }
    });

    // Apply primary filtering based on optimized thresholds
    const filteredWallets = wallets.filter(wallet => {
      // Essential filters that should always be applied

      // Must have valid win rate (primary targeting for 74-76% success)
      if (wallet.winRate && wallet.winRate < thresholds.minWinRate) return false;

      // Must have sufficient PnL to demonstrate real success
      if (wallet.totalPnL && wallet.totalPnL < thresholds.minPnL) return false;

      // Must have enough trades for statistical significance
      if (wallet.totalTrades && wallet.totalTrades < thresholds.minTrades) return false;

      // Check hold time to match our timeframe requirements if we have that data
      if (wallet.avgHoldTime && (this.config.timeframeFilters.fastTimeframe || this.config.timeframeFilters.slowTimeframe)) {
        const holdTimeMinutes = this.parseHoldTime(wallet.avgHoldTime);

        // If we only want fast timeframe wallets (1-4h)
        if (this.config.timeframeFilters.fastTimeframe && !this.config.timeframeFilters.slowTimeframe) {
          return holdTimeMinutes <= 240; // 4 hours in minutes
        }

        // If we only want slow timeframe wallets (4-48h)
        if (!this.config.timeframeFilters.fastTimeframe && this.config.timeframeFilters.slowTimeframe) {
          return holdTimeMinutes >= 240 && holdTimeMinutes <= 2880; // Between 4 and 48 hours
        }

        // If we want both timeframes, no additional filtering needed
      }

      // Enhanced filtering for 4x returns targeting

      // If wallet has known 4x consistency score, prioritize wallets with higher scores
      if (wallet.returns4xConsistency !== undefined && wallet.returns4xConsistency < 20) {
        return false; // Require at least 20% of trades to achieve 4x
      }

      // Cross-category wallets get preferential treatment
      if (wallet.address) {
        const categories = this.crossCategoryWallets.get(wallet.address) || [];
        if (categories.length > 1) {
          // For cross-category wallets, we can be slightly more lenient on some criteria
          // This helps capture more of these high-value wallets
          if (wallet.winRate && wallet.winRate >= thresholds.minWinRate * 0.95) { // 5% more lenient
            return true;
          }
        }
      }

      // Check if wallet is in our known successful wallets
      if (wallet.address && this.knownSuccessfulWallets.has(wallet.address)) {
        return true; // Always include wallets we've previously identified as successful
      }

      return true; // Passed all filters
    });

    // Enhanced sorting for better targeting of 74-76% success and 4x returns
    const sortedWallets = [...filteredWallets].sort((a, b) => {
      // Start with reputation score if available
      if (a.reputationScore !== undefined && b.reputationScore !== undefined) {
        return b.reputationScore - a.reputationScore;
      }

      // If targeting specific success rate range (74-76%)
      const aDistanceFromTarget = Math.min(
        Math.abs((a.winRate || 0) - this.config.targetSuccessRate.min),
        Math.abs((a.winRate || 0) - this.config.targetSuccessRate.max)
      );

      const bDistanceFromTarget = Math.min(
        Math.abs((b.winRate || 0) - this.config.targetSuccessRate.min),
        Math.abs((b.winRate || 0) - this.config.targetSuccessRate.max)
      );

      // If one wallet is clearly closer to target success rate
      if (Math.abs(aDistanceFromTarget - bDistanceFromTarget) > 5) {
        return aDistanceFromTarget - bDistanceFromTarget; // Lower distance is better
      }

      // If similar distance to target success rate, prioritize:

      // 1. Cross-category presence
      if (a.address && b.address) {
        const aCategoryCount = (this.crossCategoryWallets.get(a.address) || []).length;
        const bCategoryCount = (this.crossCategoryWallets.get(b.address) || []).length;

        if (aCategoryCount !== bCategoryCount) {
          return bCategoryCount - aCategoryCount; // More categories is better
        }
      }

      // 2. Higher trade count (more statistical significance)
      if (a.totalTrades && b.totalTrades && Math.abs(a.totalTrades - b.totalTrades) > 10) {
        return b.totalTrades - a.totalTrades;
      }

      // 3. Higher PnL
      if (a.totalPnL !== undefined && b.totalPnL !== undefined) {
        return b.totalPnL - a.totalPnL;
      }

      return 0;
    });

    // Get the top wallets (limit to a reasonable number)
    const maxWallets = Math.min(50, sortedWallets.length);
    return sortedWallets.slice(0, maxWallets);
  }

  /**
   * Parse hold time string to minutes
   */
  private parseHoldTime(holdTime: string): number {
    if (!holdTime) return 0;

    let totalMinutes = 0;

    // Extract days
    const dayMatch = holdTime.match(/(\d+)\s*d/i);
    if (dayMatch) {
      totalMinutes += parseInt(dayMatch[1]) * 24 * 60;
    }

    // Extract hours
    const hourMatch = holdTime.match(/(\d+)\s*h/i);
    if (hourMatch) {
      totalMinutes += parseInt(hourMatch[1]) * 60;
    }

    // Extract minutes
    const minuteMatch = holdTime.match(/(\d+)\s*m(?:in)?/i);
    if (minuteMatch) {
      totalMinutes += parseInt(minuteMatch[1]);
    }

    // Handle formats like "2:30" (2 hours 30 minutes)
    const timeMatch = holdTime.match(/(\d+):(\d+)/);
    if (timeMatch) {
      totalMinutes += parseInt(timeMatch[1]) * 60 + parseInt(timeMatch[2]);
    }

    // If nothing matched but there's a number, assume it's in hours
    if (totalMinutes === 0) {
      const numericMatch = holdTime.match(/(\d+(\.\d+)?)/);
      if (numericMatch) {
        totalMinutes = parseFloat(numericMatch[1]) * 60;
      }
    }

    return totalMinutes;
  }

  /**
   * ENHANCED: Get wallet transactions with improved robustness and error handling
   */
  private async getWalletTransactions(address: string): Promise<void> {
    if (!this.page) return;

    try {
      logger.info(`Getting transactions for wallet ${address}`);

      let retryCount = 0;
      let success = false;

      while (!success && retryCount < this.config.maxRetries) {
        try {
          // If retry, wait with exponential backoff
          if (retryCount > 0) {
            const delay = this.config.retryDelay * Math.pow(2, retryCount - 1);
            logger.info(`Retry ${retryCount}/${this.config.maxRetries} for transactions of ${address} after ${delay}ms`);
            await this.page.waitForTimeout(delay);
          }
          
          // Navigate to wallet detail page - adjust URL path for ChainEDGE
          await this.page.goto(`${this.config.baseUrl}/wallet/${address}`, {
            waitUntil: 'networkidle2',
            timeout: 60000
          });
          
          // Verify we're on the wallet detail page
          const onWalletDetail = await this.verifyCurrentPage('wallet-detail');
          if (!onWalletDetail) {
            throw new Error('Not on wallet detail page');
          }
          
          // Take screenshot of wallet page
          const screenshotPath = `wallet-page-${address.substring(0, 8)}.png`;
          await this.page.screenshot({ path: screenshotPath });
          
          // Wait for transaction data to load with adaptive selectors
          const txTableSelector = await this.findWorkingSelector([
            'table', '.transactions-table', '.tx-table', 
            '.transaction-list', '.trade-history',
            // Add structure-based selectors
            '[class*="transaction"]', '[class*="trade"]', 
            '.card + table', '.panel table'
          ], 'transactionTable');
          
          if (!txTableSelector) {
            throw new Error('Transaction table not found');
          }
          
          await this.page.waitForSelector(txTableSelector, { timeout: 15000 }).catch(() => {
            logger.warn(`No transaction table found for wallet ${address}`);
          });
          
          // Extract transaction data with improved selector targeting
          const transactions = await this.extractWalletTransactions(address);
          
          // Skip if no transactions found
          if (!transactions || transactions.length === 0) {
            logger.warn(`No transactions found for wallet ${address}`);
            success = true; // Still count as success, just no transactions
            return;
          }
          
          // Process and analyze transactions to extract valuable metrics
          const enrichedTransactions = this.analyzeTransactions(transactions);
          
          // Save transactions to database
          await this.saveWalletTransactions(address, enrichedTransactions);
          
          this.stats.transactionsProcessed += transactions.length;
          logger.info(`Saved ${transactions.length} transactions for wallet ${address}`);
          
          success = true;
        } catch (error) {
          retryCount++;
          logger.error(`Error (attempt ${retryCount}/${this.config.maxRetries}) getting transactions for wallet ${address}:`, error instanceof Error ? error.message : String(error));
          
          // If we still have retries, take a screenshot and continue
          if (retryCount < this.config.maxRetries) {
            const errorScreenshotPath = `transaction-error-${address.substring(0, 8)}-retry${retryCount}.png`;
            await this.page.screenshot({ path: errorScreenshotPath });
          } else {
            throw error; // Re-throw to be caught by outer try-catch
          }
        }
      }
    } catch (error) {
      logger.error(`Failed to get transactions for wallet ${address} after ${this.config.maxRetries} attempts:`, error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * ENHANCED: Extract transaction data with improved DOM analysis
   */
  private async extractWalletTransactions(address: string): Promise<any[]> {
    if (!this.page) return [];

    try {
      // Analyze DOM to identify transaction table structure
      const transactionTableStructure = await this.analyzeTransactionTableStructure();

      // Extract transactions with the identified structure
      return await this.page.evaluate((params) => {
        const { minBuyValue, tableStructure } = params;
        const txs: any[] = [];

        // Function to safely extract text
        const safeText = (el: Element | null): string => {
          return el?.textContent?.trim() || '';
        };

        // Function to parse numeric values including K/M suffixes
        const parseNumericValue = (text: string): number => {
          if (!text) return 0;
          
          const cleanText = text.replace(/[$,]/g, '').trim();
          
          if (cleanText.includes('K') || cleanText.includes('k')) {
            return parseFloat(cleanText.replace(/[Kk]/g, '')) * 1000;
          } else if (cleanText.includes('M') || cleanText.includes('m')) {
            return parseFloat(cleanText.replace(/[Mm]/g, '')) * 1000000;
          } else {
            return parseFloat(cleanText) || 0;
          }
        };

        // Get transaction rows using the identified selectors
        let txRows: NodeListOf<Element>;

        // Try primary selector first
        txRows = document.querySelectorAll(tableStructure.rowSelector);

        // If no rows found, try alternate selectors
        if (!txRows || txRows.length <= 1) {
          for (const selector of tableStructure.alternateRowSelectors) {
            txRows = document.querySelectorAll(selector);
            if (txRows && txRows.length > 1) break;
          }
        }

        // Fallback to generic selectors if needed
        if (!txRows || txRows.length <= 1) {
          txRows = document.querySelectorAll('table tr:not(:first-child), .transaction-row, .tx-row');
        }

        // Final fallback
        if (!txRows || txRows.length <= 1) {
          return txs;
        }

        // Process each transaction row
        txRows.forEach((row, index) => {
          // Skip header row if it's the first row and has TH elements
          if (index === 0 && row.querySelector('th')) return;
          
          try {
            // Helper function to find cell value using column map
            const getCellValue = (columnType: string): Element | null => {
              if (tableStructure.columnMap[columnType]) {
                // Try direct column index first
                if (typeof tableStructure.columnMap[columnType] === 'number') {
                  const cells = row.querySelectorAll('td');
                  const columnIndex = tableStructure.columnMap[columnType] as number;
                  if (cells.length > columnIndex) {
                    return cells[columnIndex];
                  }
                }
                
                // Try selectors
                return row.querySelector(tableStructure.columnMap[columnType] as string);
              }
              return null;
            };
            
            // Extract token information
            const tokenCell = getCellValue('token');
            const tokenSymbol = safeText(tokenCell);
            
            // Extract token address if present
            let tokenAddress = '';
            if (tokenCell) {
              const tokenAddressEl = tokenCell.querySelector('[data-token-address], [data-address]');
              tokenAddress = tokenAddressEl?.getAttribute('data-token-address') || 
                            tokenAddressEl?.getAttribute('data-address') || '';
            }
            
            // Extract buy price
            const buyPriceCell = getCellValue('buyPrice');
            let buyPrice = 0;
            if (buyPriceCell) {
              buyPrice = parseNumericValue(safeText(buyPriceCell));
            }
            
            // Extract buy amount
            const buyAmountCell = getCellValue('buyAmount');
            let buyAmount = 0;
            if (buyAmountCell) {
              buyAmount = parseNumericValue(safeText(buyAmountCell));
            }
            
            // Extract buy timestamp
            const buyTimeCell = getCellValue('buyTime');
            let buyTimestamp = new Date();
            if (buyTimeCell) {
              const timeText = safeText(buyTimeCell);
              const dateAttr = buyTimeCell.getAttribute('data-timestamp');
              
              if (dateAttr) {
                buyTimestamp = new Date(parseInt(dateAttr));
              } else if (timeText && timeText !== '-') {
                try {
                  buyTimestamp = new Date(timeText);
                } catch (e) {
                  // Keep default if parsing fails
                }
              }
            }
            
            // Extract sell price
            const sellPriceCell = getCellValue('sellPrice');
            let sellPrice = 0;
            if (sellPriceCell) {
              sellPrice = parseNumericValue(safeText(sellPriceCell));
            }
            
            // Extract sell amount
            const sellAmountCell = getCellValue('sellAmount');
            let sellAmount = 0;
            if (sellAmountCell) {
              sellAmount = parseNumericValue(safeText(sellAmountCell));
            }
            
            // Extract sell timestamp
            const sellTimeCell = getCellValue('sellTime');
            let sellTimestamp = null;
            if (sellTimeCell) {
              const timeText = safeText(sellTimeCell);
              const dateAttr = sellTimeCell.getAttribute('data-timestamp');
              
              if (dateAttr) {
                sellTimestamp = new Date(parseInt(dateAttr));
              } else if (timeText && timeText !== '-') {
                try {
                  sellTimestamp = new Date(timeText);
                } catch (e) {
                  // Keep null if parsing fails
                }
              }
            }
            
            // Extract PnL value and percentage
            const pnlCell = getCellValue('pnl');
            let pnlValue = 0;
            if (pnlCell) {
              const pnlText = safeText(pnlCell);
              pnlValue = parseNumericValue(pnlText);
              
              // Check for negative indicator
              if (pnlText.includes('-') && pnlValue > 0) {
                pnlValue = -pnlValue;
              }
            }
            
            // Extract PnL percentage
            const pnlPercentCell = getCellValue('pnlPercent');
            let pnlPercentage = 0;
            if (pnlPercentCell) {
              const percentText = safeText(pnlPercentCell);
              pnlPercentage = parseFloat(percentText.replace(/[^0-9.-]/g, ''));
              
              // Check for negative indicator
              if (percentText.includes('-') && pnlPercentage > 0) {
                pnlPercentage = -pnlPercentage;
              }
            } else if (sellPrice > 0 && buyPrice > 0) {
              // Calculate if not provided
              pnlPercentage = ((sellPrice - buyPrice) / buyPrice) * 100;
            }
            
            // Extract transaction value
            const txValueCell = getCellValue('txValue');
            let transactionValue = 0;
            if (txValueCell) {
              transactionValue = parseNumericValue(safeText(txValueCell));
            } else {
              // Calculate from buy price and amount if available
              transactionValue = buyPrice * buyAmount;
            }
            
            // Skip small transactions
            if (transactionValue < minBuyValue) {
              return;
            }
            
            // Default to Solana for chain/network
            let chain = 'solana';
            
            // Extract chain/network if available
            const chainCell = getCellValue('chain');
            if (chainCell) {
              const chainText = safeText(chainCell).toLowerCase();
              if (chainText) {
                chain = chainText;
              }
            }
            
            // Calculate holding period if we have both buy and sell timestamps
            let holdingPeriodMinutes = 0;
            if (sellTimestamp) {
              holdingPeriodMinutes = Math.round((sellTimestamp.getTime() - buyTimestamp.getTime()) / (1000 * 60));
            }
            
            // Create transaction object with timeframe classification
            const tx = {
              tokenSymbol: tokenSymbol || 'Unknown',
              tokenAddress: tokenAddress || '',
              buyPrice,
              sellPrice,
              buyAmount,
              sellAmount,
              buyTimestamp,
              sellTimestamp,
              pnlValue,
              pnlPercentage,
              transactionValue,
              chain,
              isSuccessful: pnlValue > 0,
              // Enhanced fields for timeframe analysis
              holdTimeMinutes: holdingPeriodMinutes,
              timeframe: (holdingPeriodMinutes > 0 && holdingPeriodMinutes <= 240) ? 'fast' : 
                        (holdingPeriodMinutes > 240 && holdingPeriodMinutes <= 2880) ? 'slow' : 'other',
              multiplier: sellPrice > 0 ? (sellPrice / buyPrice) : 0
            };
            
            txs.push(tx);
          } catch (error) {
            console.error('Error parsing transaction row:', error);
          }
        });

        return txs;
      }, { 
        minBuyValue: this.config.minBuyValue,
        tableStructure: transactionTableStructure 
      });
    } catch (error) {
      logger.error(`Error extracting transaction data for wallet ${address}:`, error instanceof Error ? error.message : String(error));
      return [];
    }
  }

  /**
   * ENHANCED: Analyze transaction table structure
   */
  private async analyzeTransactionTableStructure(): Promise<{
    rowSelector: string;
    alternateRowSelectors: string[];
    columnMap: Record<string, string | number>;
  }> {
    if (!this.page) {
      return {
        rowSelector: 'table tr:not(:first-child)',
        alternateRowSelectors: ['.transaction-row', '.tx-row', 'tbody tr:not(:first-child)'],
        columnMap: {}
      };
    }

    try {
      return await this.page.evaluate(() => {
        const structure = {
          rowSelector: 'table tr:not(:first-child)',
          alternateRowSelectors: [
            '.transaction-row', 
            '.tx-row', 
            '.trade-row',
            'tbody tr:not(:first-child)'
          ],
          columnMap: {} as Record<string, string | number>
        };

        // Find all tables that might contain transaction data
        const tables = document.querySelectorAll('table');

        // Function to check if table is likely a transaction table
        const isTransactionTable = (table: Element): boolean => {
          // Check if it has multiple rows
          const rows = table.querySelectorAll('tbody tr, tr');
          if (rows.length < 2) return false;
          
          // Check if header row contains transaction-related text
          const headerRow = table.querySelector('thead tr, tr:first-child');
          if (!headerRow) return false;
          
          const headerText = headerRow.textContent?.toLowerCase() || '';
          return headerText.includes('transaction') || 
                 headerText.includes('trade') || 
                 headerText.includes('token') || 
                 headerText.includes('buy') || 
                 headerText.includes('sell') || 
                 headerText.includes('price') || 
                 headerText.includes('time');
        };

        // Find transaction tables
        let transactionTable: Element | null = null;
        for (const table of tables) {
          if (isTransactionTable(table)) {
            transactionTable = table;
            break;
          }
        }

        if (!transactionTable) {
          // No transaction table found, use default structure
          return structure;
        }

        // Set specific row selector for this table
        const tableIndex = Array.from(tables).indexOf(transactionTable) + 1;
        structure.rowSelector = `table:nth-of-type(${tableIndex}) tr:not(:first-child)`;

        // Analyze header row to map columns
        const headerRow = transactionTable.querySelector('thead tr, tr:first-child');
        if (headerRow) {
          const headerCells = headerRow.querySelectorAll('th, td');
          
          headerCells.forEach((cell, index) => {
            const text = cell.textContent?.toLowerCase().trim() || '';
            
            // Map column types based on header text
            if (text.includes('token') || text.includes('coin') || text.includes('asset')) {
              structure.columnMap['token'] = index;
            } else if (text.includes('buy') && text.includes('price')) {
              structure.columnMap['buyPrice'] = index;
            } else if (text.includes('sell') && text.includes('price')) {
              structure.columnMap['sellPrice'] = index;
            } else if (text.includes('buy') && text.includes('amount')) {
              structure.columnMap['buyAmount'] = index;
            } else if (text.includes('sell') && text.includes('amount')) {
              structure.columnMap['sellAmount'] = index;
            } else if (text.includes('buy') && (text.includes('time') || text.includes('date'))) {
              structure.columnMap['buyTime'] = index;
            } else if (text.includes('sell') && (text.includes('time') || text.includes('date'))) {
              structure.columnMap['sellTime'] = index;
            } else if (text === 'pnl' || text.includes('profit') || text.includes('loss')) {
              structure.columnMap['pnl'] = index;
            } else if (text.includes('pnl %') || text.includes('roi') || text.includes('%')) {
              structure.columnMap['pnlPercent'] = index;
            } else if (text.includes('value') || text.includes('size')) {
              structure.columnMap['txValue'] = index;
            } else if (text.includes('chain') || text.includes('network')) {
              structure.columnMap['chain'] = index;
            } else if (text.includes('entry') && text.includes('price')) {
              structure.columnMap['buyPrice'] = index;
            } else if (text.includes('exit') && text.includes('price')) {
              structure.columnMap['sellPrice'] = index;
            } else if (text.includes('entry') && text.includes('time')) {
              structure.columnMap['buyTime'] = index;
            } else if (text.includes('exit') && text.includes('time')) {
              structure.columnMap['sellTime'] = index;
            }
          });
        }

        return structure;
      });
    } catch (error) {
      logger.error('Error analyzing transaction table structure:', error instanceof Error ? error.message : String(error));

      // Return default structure
      return {
        rowSelector: 'table tr:not(:first-child)',
        alternateRowSelectors: ['.transaction-row', '.tx-row', 'tbody tr:not(:first-child)'],
        columnMap: {}
      };
    }
  }

  /**
   * Analyze transactions to extract key metrics for meme coin success
   */
  private analyzeTransactions(transactions: any[]): ClassifiedTransaction[] {
    // Categorize transactions by timeframe
    const fastTimeframeTransactions = transactions.filter(tx => 
      tx.holdTimeMinutes > 0 && tx.holdTimeMinutes <= 240);

    const slowTimeframeTransactions = transactions.filter(tx => 
      tx.holdTimeMinutes > 240 && tx.holdTimeMinutes <= 2880);

    // Analyze meme tokens (indicators: high volatility, >4x potential)
    const memeTokenTransactions = transactions.filter(tx => 
      (tx.pnlPercentage > 100 || tx.multiplier >= 2));

    // Calculate timeframe success rates
    const fastTimeframeSuccess = fastTimeframeTransactions.filter(tx => tx.isSuccessful).length / 
                           (fastTimeframeTransactions.length || 1);

    const slowTimeframeSuccess = slowTimeframeTransactions.filter(tx => tx.isSuccessful).length / 
                           (slowTimeframeTransactions.length || 1);

    // Enhance transactions with additional metadata
    return transactions.map(tx => ({
      ...tx,
      // Add metadata about this transaction type's success rate
      meta: {
        timeframeSuccessRate: tx.timeframe === 'fast' ? fastTimeframeSuccess * 100 : 
                            tx.timeframe === 'slow' ? slowTimeframeSuccess * 100 : 0,
        isMemeToken: memeTokenTransactions.some(m => 
          m.tokenAddress === tx.tokenAddress && m.tokenSymbol === tx.tokenSymbol),
        // Higher entry timing score means they got in earlier
        entryTimingScore: tx.multiplier >= 4 ? 100 : tx.multiplier >= 2 ? 75 : tx.multiplier >= 1.5 ? 50 : 25
      }
    }));
  }

  /**
   * Save wallet data to database with enhanced metrics
   */
  private async saveWallet(walletData: EnhancedWalletData): Promise<void> {
    try {
      // Check if wallet already exists
      let wallet = await ExternalWallet.findOne({ address: walletData.address });

      if (wallet) {
        // Update existing wallet with basic fields
        wallet.winRate = walletData.winRate || wallet.winRate;
        wallet.totalPnL = walletData.totalPnL || wallet.totalPnL;
        wallet.successfulTrades = walletData.successfulTrades || wallet.successfulTrades;
        wallet.totalTrades = walletData.totalTrades || wallet.totalTrades;
        wallet.avgHoldTime = walletData.avgHoldTime || wallet.avgHoldTime;
        wallet.category = walletData.category || wallet.category;
        wallet.lastUpdated = new Date();

        // Update prediction and confidence if present
        if (walletData.predictedSuccessRate !== undefined) {
          wallet.metadata = {
            ...wallet.metadata,
            predictedSuccessRate: walletData.predictedSuccessRate
          };
        }

        if (walletData.confidenceScore !== undefined) {
          wallet.metadata = {
            ...wallet.metadata,
            confidenceScore: walletData.confidenceScore
          };
        }

        // Update 4x consistency if present
        if (walletData.returns4xConsistency !== undefined) {
          wallet.metadata = {
            ...wallet.metadata,
            returns4xConsistency: walletData.returns4xConsistency
          };
        }

        // Keep transactions intact - we'll update them separately

        await wallet.save();
        logger.info(`Updated wallet ${walletData.address}`);
      } else {
        // Create new wallet
        wallet = new ExternalWallet({
          address: walletData.address,
          network: walletData.network || 'solana',
          category: walletData.category,
          winRate: walletData.winRate || 0,
          totalPnL: walletData.totalPnL || 0,
          successfulTrades: walletData.successfulTrades || 0,
          totalTrades: walletData.totalTrades || 0,
          avgHoldTime: walletData.avgHoldTime || '',
          firstSeen: new Date(),
          lastUpdated: new Date(),
          isActive: true,
          transactions: [], // Start with empty transactions
          // Initialize metadata
          metadata: {
            preferredTokens: [],
            tradingFrequency: this.calculateTradingFrequency(walletData.totalTrades || 0),
            lastActiveTimestamp: new Date(),
            predictedSuccessRate: walletData.predictedSuccessRate,
            confidenceScore: walletData.confidenceScore,
            returns4xConsistency: walletData.returns4xConsistency
          }
        });

        await wallet.save();
        logger.info(`Created new wallet ${walletData.address}`);
      }
    } catch (error) {
      logger.error(`Error saving wallet ${walletData.address}:`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }

  /**
   * ENHANCED: Save wallet transactions with additional metrics for 4x targeting
   */
  private async saveWalletTransactions(address: string, transactions: ClassifiedTransaction[]): Promise<void> {
    try {
      // Get wallet from database
      const wallet = await ExternalWallet.findOne({ address });

      if (!wallet) {
        logger.error(`Wallet ${address} not found for transaction update`);
        return;
      }

      // Update transactions
      wallet.transactions = transactions;

      // Update metadata with enhanced metrics

      // 1. Calculate timeframe-specific metrics
      const fastTimeframeTransactions = transactions.filter(tx => tx.timeframe === 'fast');
      const slowTimeframeTransactions = transactions.filter(tx => tx.timeframe === 'slow');
      const memeTokenTransactions = transactions.filter(tx => 
        tx.meta?.isMemeToken || tx.multiplier >= 4 || tx.pnlPercentage >= 300);

      // 2. Calculate preferred tokens
      const tokenFrequency: Record<string, number> = {};
      transactions.forEach(tx => {
        const symbol = tx.tokenSymbol || 'unknown';
        tokenFrequency[symbol] = (tokenFrequency[symbol] || 0) + 1;
      });

      // Sort by frequency and get top 5
      const preferredTokens = Object.entries(tokenFrequency)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(entry => entry[0]);

      // 3. Calculate average multipliers
      const fastTimeframeMultiplier = this.calculateAverageMultiplier(fastTimeframeTransactions);
      const slowTimeframeMultiplier = this.calculateAverageMultiplier(slowTimeframeTransactions);
      const memeTokenMultiplier = this.calculateAverageMultiplier(memeTokenTransactions);

      // 4. Calculate success rates
      const fastTimeframeSuccessRate = this.calculateSuccessRate(fastTimeframeTransactions);
      const slowTimeframeSuccessRate = this.calculateSuccessRate(slowTimeframeTransactions);
      const memeTokenSuccessRate = this.calculateSuccessRate(memeTokenTransactions);

      // 5. Calculate entry timing
      const entryTimingScore = transactions
        .filter(tx => tx.meta?.entryTimingScore)
        .reduce((sum, tx) => sum + (tx.meta?.entryTimingScore || 0), 0) / 
        (transactions.filter(tx => tx.meta?.entryTimingScore).length || 1);

      // 6. ENHANCED: Calculate early vs. late entry metrics
      const earlyEntryMetrics = this.calculateEarlyEntryMetrics(transactions);

      // 7. ENHANCED: Calculate 4x achievement analysis
      const fourXAnalysis = this.calculate4xAnalysis(transactions);

      // 8. ENHANCED: Calculate optimal holding period for 4x returns
      const optimalHoldingPeriod = this.calculateOptimalHoldingPeriod(transactions);

      // Update wallet with enhanced metrics
      wallet.metadata = {
        ...wallet.metadata,
        preferredTokens,
        tradingFrequency: this.calculateTradingFrequency(wallet.totalTrades || 0),
        lastActiveTimestamp: new Date(),
        // Enhanced metrics for targeted meme coin detection
        fastTimeframeStats: {
          count: fastTimeframeTransactions.length,
          successRate: fastTimeframeSuccessRate,
          avgMultiplier: fastTimeframeMultiplier
        },
        slowTimeframeStats: {
          count: slowTimeframeTransactions.length,
          successRate: slowTimeframeSuccessRate,
          avgMultiplier: slowTimeframeMultiplier
        },
        memeTokenStats: {
          count: memeTokenTransactions.length,
          successRate: memeTokenSuccessRate,
          avgMultiplier: memeTokenMultiplier
        },
        entryTimingScore: entryTimingScore,
        // 4x score - specifically for our meme coin 4x minimum return goal
        achieves4xScore: fourXAnalysis.achievementPercentage,
        // ENHANCED: Additional metrics for optimizing 4x returns
        earlyEntryScore: earlyEntryMetrics.earlyEntryScore,
        entryTimingDistribution: earlyEntryMetrics.entryTimingDistribution,
        optimalHoldingMinutes: optimalHoldingPeriod.optimalMinutes,
        optimalHoldingSuccess: optimalHoldingPeriod.successRate,
        // Categories this wallet appears in
        categoryCrossover: this.crossCategoryWallets.get(address) || []
      };

      // Calculate the overall reputation score based on our goal
      const memeMultiplierWeight = 0.4;  // 40% weight for meme token multiplier
      const successRateWeight = 0.3;     // 30% weight for success rate
      const entryTimingWeight = 0.2;     // 20% weight for entry timing
      const tradeCountWeight = 0.1;      // 10% weight for trade count

      // Calculate score components
      const memeMultiplierScore = Math.min(100, (memeTokenMultiplier / 4) * 100); // Normalize to 4x target
      const successRateScore = wallet.winRate;
      const entryTimingScoreNormalized = entryTimingScore;
      const tradeCountScore = Math.min(100, ((wallet.totalTrades || 0) / 50) * 100); // 50+ trades is ideal

      // ENHANCED: Additional score component for 4x achievement
      const fourXWeight = 0.3; // 30% weight for 4x achievement
      const fourXScore = Math.min(100, fourXAnalysis.achievementPercentage);

      // ENHANCED: Adjust weights to include 4x achievement
      const totalWeight = memeMultiplierWeight + successRateWeight + entryTimingWeight + tradeCountWeight + fourXWeight;
      const normalizedMemeMultiplierWeight = memeMultiplierWeight / totalWeight;
      const normalizedSuccessRateWeight = successRateWeight / totalWeight;
      const normalizedEntryTimingWeight = entryTimingWeight / totalWeight;
      const normalizedTradeCountWeight = tradeCountWeight / totalWeight;
      const normalizedFourXWeight = fourXWeight / totalWeight;

      // Calculate weighted score with 4x achievement component
      const weightedScore = (
        memeMultiplierScore * normalizedMemeMultiplierWeight +
        successRateScore * normalizedSuccessRateWeight +
        entryTimingScoreNormalized * normalizedEntryTimingWeight +
        tradeCountScore * normalizedTradeCountWeight +
        fourXScore * normalizedFourXWeight
      );

      // ENHANCED: Cross-category bonus
      const categories = this.crossCategoryWallets.get(address) || [];
      const crossCategoryBonus = categories.length > 1 ? (categories.length - 1) * 5 : 0;

      // Update reputation score with cross-category bonus
      wallet.reputationScore = Math.min(100, weightedScore + crossCategoryBonus);

      // ENHANCED: Update predicted success rate based on all available data
      if (wallet.metadata) {
        wallet.metadata.predictedSuccessRate = this.predictWalletSuccessRate({
          ...wallet,
          returns4xConsistency: fourXAnalysis.achievementPercentage
        });
      }

      // Save all updates
      await wallet.save();

      logger.info(`Updated wallet ${address} with ${transactions.length} transactions and enhanced metrics`);

      // ENHANCED: Cache the processed wallet data
      if (address) {
        this.walletCache.set(address, {
          data: {
            address,
            network: wallet.network,
            category: wallet.category,
            winRate: wallet.winRate,
            totalPnL: wallet.totalPnL,
            successfulTrades: wallet.successfulTrades,
            totalTrades: wallet.totalTrades,
            avgHoldTime: wallet.avgHoldTime,
            reputationScore: wallet.reputationScore,
            predictedSuccessRate: wallet.metadata?.predictedSuccessRate,
            confidenceScore: wallet.metadata?.confidenceScore,
            returns4xConsistency: fourXAnalysis.achievementPercentage
          },
          timestamp: Date.now()
        });
      }
    } catch (error) {
      logger.error(`Error saving transactions for wallet ${address}:`, error instanceof Error ? error.message : String(error));
      throw error;
    }
  }

  /**
   * ENHANCED: Calculate early entry metrics
   */
  private calculateEarlyEntryMetrics(transactions: ClassifiedTransaction[]): {
    earlyEntryScore: number;
    entryTimingDistribution: { early: number; mid: number; late: number; };
  } {
    // Filter to completed trades
    const completedTrades = transactions.filter(tx => tx.sellTimestamp !== null);
    if (completedTrades.length === 0) {
      return { 
        earlyEntryScore: 0,
        entryTimingDistribution: { early: 0, mid: 0, late: 0 }
      };
    }

    // Calculate early entry metrics
    let earlyEntryCount = 0;
    let midEntryCount = 0;
    let lateEntryCount = 0;

    // Categorize each trade by entry timing
    completedTrades.forEach(tx => {
      if (tx.meta?.entryTimingScore && tx.meta.entryTimingScore >= 75) {
        earlyEntryCount++;
      } else if (tx.meta?.entryTimingScore && tx.meta.entryTimingScore >= 50) {
        midEntryCount++;
      } else {
        lateEntryCount++;
      }
    });

    // Calculate distribution
    const total = completedTrades.length;
    const earlyPercentage = (earlyEntryCount / total) * 100;
    const midPercentage = (midEntryCount / total) * 100;
    const latePercentage = (lateEntryCount / total) * 100;

    // Calculate overall early entry score (weighted towards early entries)
    const earlyEntryScore = 
      (earlyPercentage * 1.0) + 
      (midPercentage * 0.5) + 
      (latePercentage * 0.1);

    return {
      earlyEntryScore,
      entryTimingDistribution: {
        early: earlyPercentage,
        mid: midPercentage,
        late: latePercentage
      }
    };
  }

  /**
   * ENHANCED: Calculate detailed 4x achievement analysis
   */
  private calculate4xAnalysis(transactions: ClassifiedTransaction[]): {
    achievementPercentage: number;
    timeframeBreakdown: { fast: number; slow: number; };
    averageTimeToAchieve: number;
  } {
    // Filter to completed trades
    const completedTrades = transactions.filter(tx => tx.sellTimestamp !== null);
    if (completedTrades.length === 0) {
      return { 
        achievementPercentage: 0,
        timeframeBreakdown: { fast: 0, slow: 0 },
        averageTimeToAchieve: 0
      };
    }

    // Count trades with 4x or greater returns
    const fourXTrades = completedTrades.filter(tx => tx.multiplier >= 4);

    // Calculate percentage
    const achievementPercentage = (fourXTrades.length / completedTrades.length) * 100;

    // Break down by timeframe
    const fastFourXTrades = fourXTrades.filter(tx => tx.timeframe === 'fast');
    const slowFourXTrades = fourXTrades.filter(tx => tx.timeframe === 'slow');

    const fastPercentage = fastFourXTrades.length > 0 ? 
      (fastFourXTrades.length / fourXTrades.length) * 100 : 0;

    const slowPercentage = slowFourXTrades.length > 0 ? 
      (slowFourXTrades.length / fourXTrades.length) * 100 : 0;

    // Calculate average time to achieve 4x
    const timeToAchieve = fourXTrades.length > 0 ?
      fourXTrades.reduce((sum, tx) => sum + tx.holdTimeMinutes, 0) / fourXTrades.length : 0;

    return {
      achievementPercentage,
      timeframeBreakdown: {
        fast: fastPercentage,
        slow: slowPercentage
      },
      averageTimeToAchieve: timeToAchieve
    };
  }

  /**
   * ENHANCED: Calculate optimal holding period for 4x returns
   */
  private calculateOptimalHoldingPeriod(transactions: ClassifiedTransaction[]): {
    optimalMinutes: number;
    successRate: number;
  } {
    // Filter to completed trades
    const completedTrades = transactions.filter(tx => tx.sellTimestamp !== null);
    if (completedTrades.length === 0) {
      return { optimalMinutes: 0, successRate: 0 };
    }

    // Group by holding period in chunks (hourly)
    const hourlyBuckets: Record<number, { trades: number; successes: number; }> = {};

    completedTrades.forEach(tx => {
      // Round holding time to nearest hour (bucket)
      const hourBucket = Math.floor(tx.holdTimeMinutes / 60);

      if (!hourlyBuckets[hourBucket]) {
        hourlyBuckets[hourBucket] = { trades: 0, successes: 0 };
      }

      hourlyBuckets[hourBucket].trades++;

      // Count as success if multiplier >= 4
      if (tx.multiplier >= 4) {
        hourlyBuckets[hourBucket].successes++;
      }
    });

    // Find bucket with best success rate (minimum 3 trades for statistical relevance)
    let bestBucket = 0;
    let bestSuccessRate = 0;

    Object.entries(hourlyBuckets).forEach(([hourBucket, data]) => {
      if (data.trades >= 3) {
        const successRate = (data.successes / data.trades) * 100;
        if (successRate > bestSuccessRate) {
          bestSuccessRate = successRate;
          bestBucket = parseInt(hourBucket);
        }
      }
    });

    // Convert back to minutes (mid-point of hour bucket)
    const optimalMinutes = (bestBucket * 60) + 30;

    return {
      optimalMinutes,
      successRate: bestSuccessRate
    };
  }

  /**
   * Calculate average multiplier for a set of transactions
   */
  private calculateAverageMultiplier(transactions: ClassifiedTransaction[]): number {
    if (!transactions.length) return 0;

    // Filter to completed trades only
    const completedTrades = transactions.filter(tx => tx.sellTimestamp !== null);
    if (!completedTrades.length) return 0;

    // Calculate average multiplier
    return completedTrades.reduce((sum, tx) => sum + (tx.multiplier || 0), 0) / completedTrades.length;
  }

  /**
   * Calculate success rate for a set of transactions
   */
  private calculateSuccessRate(transactions: ClassifiedTransaction[]): number {
    if (!transactions.length) return 0;

    const successfulTrades = transactions.filter(tx => tx.isSuccessful).length;
    return (successfulTrades / transactions.length) * 100;
  }

  /**
   * Calculate trading frequency label
   */
  private calculateTradingFrequency(tradeCount: number): string {
    if (tradeCount >= 500) return 'Very High';
    if (tradeCount >= 200) return 'High';
    if (tradeCount >= 50) return 'Medium';
    if (tradeCount >= 10) return 'Low';
    return 'Very Low';
  }

  /**
   * ENHANCED: Get high quality wallets with additional filtering targeting 74-76% success
   */
  async getHighQualityWallets(options: {
    minWinRate?: number;
    minReputation?: number;
    minMemeSuccess?: number;
    limit?: number;
    targetSuccessRate?: {
      min: number;
      max: number;
    };
  } = {}): Promise<IExternalWallet[]> {
    try {
      // Set default filters
      const minWinRate = options.minWinRate || this.config.minWinRate;
      const minReputation = options.minReputation || 75;
      const minMemeSuccess = options.minMemeSuccess || 60;
      const limit = options.limit || 20;

      // Use target success rate if provided, otherwise use config
      const targetMin = options.targetSuccessRate?.min || this.config.targetSuccessRate.min;
      const targetMax = options.targetSuccessRate?.max || this.config.targetSuccessRate.max;

      // ENHANCED: Create a query that targets the success rate range
      // We want wallets with either actual win rate or predicted success rate in range
      const query = {
        $or: [
          { winRate: { $gte: targetMin, $lte: targetMax } },
          { 'metadata.predictedSuccessRate': { $gte: targetMin, $lte: targetMax } }
        ],
        reputationScore: { $gte: minReputation },
        'metadata.memeTokenStats.successRate': { $gte: minMemeSuccess },
        'metadata.achieves4xScore': { $gte: 30 } // At least 30% of trades achieve 4x
      };

      // ENHANCED: Use projection to get just the fields we need
      const wallets = await ExternalWallet.find(query)
        .sort({ reputationScore: -1 })
        .limit(limit);

      // ENHANCED: Log success rate distribution of returned wallets
      this.logSuccessRateDistribution(wallets);

      return wallets;
    } catch (error) {
      logger.error('Error getting high quality wallets:', error instanceof Error ? error.message : String(error));
      return [];
    }
  }

  /**
   * ENHANCED: Log success rate distribution of returned wallets
   */
  private logSuccessRateDistribution(wallets: IExternalWallet[]): void {
    if (wallets.length === 0) return;

    // Count wallets in each success rate band
    const distribution: Record<string, number> = {
      'Below 70%': 0,
      '70-73%': 0,
      '74-76%': 0, // Target range
      '77-80%': 0,
      'Above 80%': 0
    };

    wallets.forEach(wallet => {
      const winRate = wallet.winRate;

      if (winRate < 70) {
        distribution['Below 70%']++;
      } else if (winRate < 74) {
        distribution['70-73%']++;
      } else if (winRate <= 76) {
        distribution['74-76%']++;
      } else if (winRate <= 80) {
        distribution['77-80%']++;
      } else {
        distribution['Above 80%']++;
      }
    });

    // Calculate percentage in target range
    const targetRangePercentage = (distribution['74-76%'] / wallets.length) * 100;

    logger.info(`Success rate distribution of ${wallets.length} high quality wallets:`);
    Object.entries(distribution).forEach(([range, count]) => {
      logger.info(`  ${range}: ${count} wallets (${((count / wallets.length) * 100).toFixed(1)}%)`);
    });
    logger.info(`Target range (74-76%) coverage: ${targetRangePercentage.toFixed(1)}%`);
  }

  /**
   * Get statistics about the scraper
   */
  getStats(): any {
    // ENHANCED: Add more detailed statistics
    return {
      ...this.stats,
      isRunning: this.isRunning,
      isLoggedIn: this.isLoggedIn,
      targetSuccessRate: this.config.targetSuccessRate,
      categorySuccessRates: this.categorySuccessRates,
      crossCategoryWallets: this.crossCategoryWallets.size,
      cacheSize: this.walletCache.size,
      knownSuccessfulWallets: this.knownSuccessfulWallets.size
    };
  }

  /**
   * Force an immediate scrape
   */
  async forceScrape(): Promise<void> {
    try {
      await this.scrapeWallets();
    } catch (error) {
      logger.error('Error in forced scrape:', error instanceof Error ? error.message : String(error));
      throw error;
    }
  }

  /**
   * Clean up resources
   */
  private async cleanup(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
      this.page = null;
      this.isLoggedIn = false;
    }

    // Save cache before cleanup
    this.saveWalletCache();

    logger.info('Cleaned up ChainEDGE scraper resources');
  }

  /**
   * Shut down the scraper
   */
  async shutdown(): Promise<void> {
    this.isRunning = false;
    await this.cleanup();
    logger.info('ChainEDGE scraper shut down');
  }

  /**
   * ENHANCED: Save wallet cache to disk
   */
  private saveWalletCache(): void {
    try {
      const cacheData: Record<string, any> = {};

      this.walletCache.forEach((value, key) => {
        cacheData[key] = value;
      });

      const cachePath = path.join(this.config.cacheDirectory, 'wallet-cache.json');
      fs.writeFileSync(cachePath, JSON.stringify(cacheData), 'utf8');

      logger.info(`Saved ${this.walletCache.size} wallets to cache`);
    } catch (error) {
      logger.error('Error saving wallet cache:', error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * ENHANCED: Load wallet cache from disk
   */
  private loadWalletCache(): void {
    try {
      const cachePath = path.join(this.config.cacheDirectory, 'wallet-cache.json');

      if (fs.existsSync(cachePath)) {
        const cacheData = JSON.parse(fs.readFileSync(cachePath, 'utf8'));

        Object.entries(cacheData).forEach(([key, value]: [string, any]) => {
          this.walletCache.set(key, value);
          
          // Also add to cross-category tracking if appropriate
          if (value.data.category) {
            this.trackWalletCategory(key, value.data.category);
          }
          
          // Add to known successful wallets if in target range
          if (value.data.winRate >= this.config.targetSuccessRate.min && 
              value.data.winRate <= this.config.targetSuccessRate.max) {
            this.knownSuccessfulWallets.add(key);
          }
        });

        logger.info(`Loaded ${this.walletCache.size} wallets from cache`);
      }
    } catch (error) {
      logger.error('Error loading wallet cache:', error instanceof Error ? error.message : String(error));
    }
  }
}

// Create a singleton instance with default configuration
let chainEDGEScraperInstance: ChainEDGEScraper | null = null;

/**
 * Get or create the ChainEDGEScraper instance
 */
export const getChainEDGEScraper = (config?: Partial<ChainEDGEConfig>): ChainEDGEScraper => {
  if (!chainEDGEScraperInstance) {
    chainEDGEScraperInstance = new ChainEDGEScraper(config);
  }
  return chainEDGEScraperInstance;
};.filter(wallet
        }

        console.log(`Found ${walletElements.length} wallet elements with selector: ${usedSelector}`);

        // Process each wallet element
        Array.from(walletElements).forEach((row, index) => {
          try {
            // Extract address with multiple approaches
            let address = '';
            
            // Try DOM analysis address columns
            for (const selector of domAnalysis.addressSelectors) {
              const addressElement = row.querySelector(selector);
              if (addressElement) {
                // Try text content first
                address = addressElement.textContent?.trim() || '';
                
                // If address looks truncated, try attributes
                if (address.includes('...')) {
                  address = addressElement.getAttribute('data-address') || 
                           addressElement.getAttribute('title') || 
                           addressElement.getAttribute('data-original') || 
                           address;
                }
                
                // If we found a valid address, break
                if (address && !address.includes('...')) {
                  break;
                }
              }
            }
            
            // If no address found, try extracting from generic elements
            if (!address || address.includes('...')) {
              const addressSelectors = [
                '.address', '.wallet-address', '[data-address]', '.address-text',
                'a[href*="wallet/"]', 'a[href*="address/"]', '[title*="0x"]',
                'td:nth-child(1)', '.address-column', '.wallet-id', '.trader-id'
              ];
              
              address = extractTextBySelectors(row, addressSelectors);
              
              // If address contains ellipsis, try to get from data attribute or title
              if (!address || address.includes('...')) {
                const addressEl = row.querySelector(addressSelectors.join(', '));
                if (addressEl) {
                  address = addressEl.getAttribute('data-address') || 
                           addressEl.getAttribute('title') || 
                           addressEl.getAttribute('data-original') || 
                           address;
                }
              }
              
              // Try to extract from href if nothing else worked
              if (!address || address.includes('...')) {
                const link = row.querySelector('a[href*="wallet/"], a[href*="address/"]');
                if (link) {
                  const href = link.getAttribute('href') || '';
                  const matches = href.match(/\/(wallet|address)\/([^/?#]+)/);
                  if (matches && matches[2]) {
                    address = matches[2];
                  }
                }
              }
            }
            
            // Skip if no valid address found
            if (!address || address.includes('...')) {
              console.warn(`Row ${index} skipped: Invalid address "${address}"`);
              return;
            }
            
            // Extract win rate with multiple approaches
            let winRateText = '';
            let winRate = 0;
            
            // Try DOM analysis win rate columns
            for (const selector of domAnalysis.winRateSelectors) {
              const winRateElement = row.querySelector(selector);
              if (winRateElement) {
                winRateText = winRateElement.textContent?.trim() || '';
                winRate = parseFloat(winRateText.replace(/%/g, '')) || 0;
                if (winRate > 0) {
                  break;
                }
              }
            }
            
            // If no win rate found, try generic selectors
            if (winRate === 0) {
              const winRateSelectors = [
                '.win-rate', '.success-rate', '[data-win-rate]', '.wr',
                '.win-percentage', 'td:nth-child(2)', '.win-rate-column',
                '.success-percentage', '.rate', '.win-pct'
              ];
              winRateText = extractTextBySelectors(row, winRateSelectors, '0%');
              winRate = parseFloat(winRateText.replace(/%/g, '')) || 0;
            }
            
            // Extract PNL with multiple approaches
            let pnlText = '';
            let totalPnL = 0;
            
            // Try DOM analysis PNL columns
            for (const selector of domAnalysis.pnlSelectors) {
              const pnlElement = row.querySelector(selector);
              if (pnlElement) {
                pnlText = pnlElement.textContent?.trim() || '';
                totalPnL = parseNumericValue(pnlText);
                if (totalPnL > 0) {
                  break;
                }
              }
            }
            
            // If no PNL found, try generic selectors
            if (totalPnL === 0) {
              const pnlSelectors = [
                '.pnl', '.profit', '[data-pnl]', '.profit-loss',
                '.earnings', 'td:nth-child(3)', '.pnl-column',
                '.total-profit', '.net-profit', '.p-n-l'
              ];
              pnlText = extractTextBySelectors(row, pnlSelectors, '$0');
              totalPnL = parseNumericValue(pnlText);
            }
            
            // Extract trades with multiple approaches
            let tradesText = '';
            let successfulTrades = 0;
            let totalTrades = 0;
            
            // Try DOM analysis trades columns
            for (const selector of domAnalysis.tradesSelectors) {
              const tradesElement = row.querySelector(selector);
              if (tradesElement) {
                tradesText = tradesElement.textContent?.trim() || '';
                
                // Handle different formats
                if (tradesText) {
                  if (tradesText.includes('/')) {
                    // Format like "225/646"
                    const parts = tradesText.split('/');
                    successfulTrades = parseInt(parts[0].trim()) || 0;
                    totalTrades = parseInt(parts[1].trim()) || 0;
                  } else {
                    // Just total trades
                    totalTrades = parseInt(tradesText.replace(/[^0-9]/g, '')) || 0;
                    // Estimate successful trades based on win rate
                    successfulTrades = Math.round(totalTrades * (winRate / 100));
                  }
                  
                  if (totalTrades > 0) {
                    break;
                  }
                }
              }
            }
            
            // If no trades found, try generic selectors
            if (totalTrades === 0) {
              const tradesSelectors = [
                '.trades', '.trade-count', '[data-trades]', '.transactions',
                '.tx-count', 'td:nth-child(4)', '.trades-column',
                '.number-of-trades', '.total-trades'
              ];
              tradesText = extractTextBySelectors(row, tradesSelectors, '0/0');
              
              if (tradesText.includes('/')) {
                // Format like "225/646"
                const parts = tradesText.split('/');
                successfulTrades = parseInt(parts[0].trim()) || 0;
                totalTrades = parseInt(parts[1].trim()) || 0;
              } else {
                // Just total trades
                totalTrades = parseInt(tradesText.replace(/[^0-9]/g, '')) || 0;
                // Estimate successful trades based on win rate
                successfulTrades = Math.round(totalTrades * (winRate / 100));
              }
            }
            
            // Extract hold time with multiple approaches
            let avgHoldTime = '';
            
            // Try DOM analysis hold time columns
            for (const selector of domAnalysis.holdTimeSelectors) {
              const holdTimeElement = row.querySelector(selector);
              if (holdTimeElement) {
                avgHoldTime = holdTimeElement.textContent?.trim() || '';
                if (avgHoldTime) {
                  break;
                }
              }
            }
            
            // If no hold time found, try generic selectors
            if (!avgHoldTime) {
              const holdTimeSelectors = [
                '.hold-time', '.avg-hold', '[data-hold-time]', '.duration',
                '.holding-period', 'td:nth-child(5)', '.hold-time-column',
                '.average-hold-time', '.avg-duration'
              ];
              avgHoldTime = extractTextBySelectors(row, holdTimeSelectors, '');
            }
            
            // Extract any other useful metrics if available
            
            // 4x consistency (if available)
            let returns4xConsistency = 0;
            const returns4xSelectors = [
              '.returns-4x', '.x4-rate', '[data-4x-rate]', '.x4-percentage',
              '.multiplier-rate', '.high-returns-rate'
            ];
            const returns4xText = extractTextBySelectors(row, returns4xSelectors);
            if (returns4xText) {
              returns4xConsistency = parseFloat(returns4xText.replace(/%/g, '')) || 0;
            }
            
            // Add wallet to results if it has valid data
            if (address && (winRate > 0 || totalPnL > 0)) {
              wallets.push({
                address,
                network: 'solana', // Default to Solana
                category,
                winRate,
                totalPnL,
                successfulTrades,
                totalTrades,
                avgHoldTime,
                isActive: true,
                lastUpdated: new Date(),
                returns4xConsistency,
                // Add metadata for enhanced analysis
                metadata: {
                  tradingFrequency: 
                    totalTrades >= 500 ? 'Very High' : 
                    totalTrades >= 200 ? 'High' : 
                    totalTrades >= 50 ? 'Medium' : 
                    totalTrades >= 10 ? 'Low' : 'Very Low'
                }
              });
            }
          } catch (error) {
            console.error(`Error parsing wallet row ${index}:`, error);
          }
        });

        return wallets;import puppeteer from 'puppeteer';
import { logger } from '../utils/logger';
import path from 'path';
import fs from 'fs';
import { ExternalWallet, IExternalWallet } from '../models/externalWallet';
import { connectToDatabase } from '../utils/database';
import { ClassifiedTransaction, EnhancedWalletData } from '../types/wallet';
import config from '../config';

// Scraper configuration type
interface ChainEDGEConfig {
  baseUrl: string;
  username: string;
  password: string;
  minWinRate: number;
  minPnL: number;
  minTrades: number;
  minTokensTraded: number;
  minBuyValue: number;
  scrapeInterval: number; // in milliseconds
  walletCategories: {
    sniper: boolean;
    gemSpotter: boolean;
    earlyMover: boolean;
  };
  timeframeFilters: {
    fastTimeframe: boolean; // 1-4 hour trades
    slowTimeframe: boolean; // 4-48 hour trades
  };
  // New optimization parameters
  targetSuccessRate: {
    min: number; // Minimum target success rate (e.g., 74)
    max: number; // Maximum target success rate (e.g., 76)
  };
  dataCacheTTL: number; // Cache time-to-live in milliseconds
  parallelProcessing: boolean; // Enable parallel processing
  maxRetries: number; // Maximum number of retries for failed operations
  retryDelay: number; // Initial delay between retries in milliseconds
  cacheDirectory: string; // Directory to store cache files
  adaptiveThresholds: boolean; // Dynamically adjust thresholds based on results
}

// Time-specific success metrics interface
interface TimeframeMetrics {
  totalTrades: number;
  successfulTrades: number;
  winRate: number;
  avgMultiplier: number;
  avgHoldTime: number; // in minutes
}

// Transaction with timeframe classification
interface ClassifiedTransaction extends IWalletTransaction {
  timeframe: 'fast' | 'slow' | 'other';
  holdTimeMinutes: number;
  multiplier: number;
  meta?: {
    timeframeSuccessRate?: number;
    isMemeToken?: boolean;
    entryTimingScore?: number;
  };
}

// Enhanced wallet data with timeframe-specific metrics
interface EnhancedWalletData extends Partial<IExternalWallet> {
  fastTimeframeMetrics?: TimeframeMetrics;
  slowTimeframeMetrics?: TimeframeMetrics;
  memeTokenMetrics?: {
    totalTrades: number;
    successfulTrades: number;
    winRate: number;
    avgMultiplier: number;
  };
  patternSuccessRates?: Record<string, number>;
  entryTiming?: number; // How early they typically get in (percentile)
  exitEfficiency?: number; // How close to top they typically exit (percentile)
  recentTransactions?: ClassifiedTransaction[];
  // New fields for success rate prediction
  predictedSuccessRate?: number;
  confidenceScore?: number; // How confident we are in the data quality
  categoryCrossover?: string[]; // Categories this wallet appears in
  returns4xConsistency?: number; // Consistency score for 4x returns
}

// Interface for selector history tracking
interface SelectorHistory {
  selector: string;
  successCount: number;
  failCount: number;
  lastSuccess: Date | null;
  lastFail: Date | null;
}

// Interface for tracking scraping jobs
interface ScrapingJobStats {
  startTime: Date;
  endTime: Date | null;
  category: string;
  walletsFound: number;
  highQualityWallets: number;
  errors: string[];
  success: boolean;
  currentSuccessRate: number | null;
}

export class ChainEDGEScraper {
  private browser: puppeteer.Browser | null = null;
  private page: puppeteer.Page | null = null;
  private config: ChainEDGEConfig;
  private isLoggedIn = false;
  private isRunning = false;
  private stats = {
    totalWalletsSeen: 0,
    walletsProcessed: 0,
    transactionsProcessed: 0,
    highValueWallets: 0,
    scrapingJobs: [] as ScrapingJobStats[],
    lastSuccessRate: null as number | null,
    adaptiveThresholdAdjustments: 0
  };

  // New fields for enhanced functionality
  private selectorHistory: Record<string, Record<string, SelectorHistory>> = {};
  private walletCache: Map<string, { data: EnhancedWalletData, timestamp: number }> = new Map();
  private knownSuccessfulWallets: Set<string> = new Set();
  private activeScrapingJobs: number = 0;
  private categorySuccessRates: Record<string, number> = {
    'Sniper': 0,
    'Gem Spotter': 0,
    'Early Mover': 0
  };
  private crossCategoryWallets: Map<string, string[]> = new Map();

  constructor(config?: Partial<ChainEDGEConfig>) {
    // Default configuration with values optimized for meme coin detection
    this.config = {
      baseUrl: config?.baseUrl || 'https://app.chainedge.io',
      username: config?.username || process.env.CHAINEDGE_USERNAME || '',
      password: config?.password || process.env.CHAINEDGE_PASSWORD || '',
      minWinRate: config?.minWinRate || 75, // Targeting high win rate for 74-76% success goal
      minPnL: config?.minPnL || 50000, // Minimum $50k profit to ensure quality
      minTrades: config?.minTrades || 30, // Statistically significant number
      minTokensTraded: config?.minTokensTraded || 10, // Ensure diverse trading history
      minBuyValue: config?.minBuyValue || 500, // Minimum buy value to filter out small trades
      scrapeInterval: config?.scrapeInterval || 3600000, // Default 1 hour
      walletCategories: {
        sniper: config?.walletCategories?.sniper !== undefined ? config.walletCategories.sniper : true,
        gemSpotter: config?.walletCategories?.gemSpotter !== undefined ? config.walletCategories.gemSpotter : true,
        earlyMover: config?.walletCategories?.earlyMover !== undefined ? config.walletCategories.earlyMover : true,
      },
      timeframeFilters: {
        fastTimeframe: config?.timeframeFilters?.fastTimeframe !== undefined ? config.timeframeFilters.fastTimeframe : true,
        slowTimeframe: config?.timeframeFilters?.slowTimeframe !== undefined ? config.timeframeFilters.slowTimeframe : true,
      },
      // New optimization parameters
      targetSuccessRate: {
        min: config?.targetSuccessRate?.min || 74,
        max: config?.targetSuccessRate?.max || 76
      },
      dataCacheTTL: config?.dataCacheTTL || 24 * 60 * 60 * 1000, // 24 hours by default
      parallelProcessing: config?.parallelProcessing || false, // Default to false for stability
      maxRetries: config?.maxRetries || 3,
      retryDelay: config?.retryDelay || 1000,
      cacheDirectory: config?.cacheDirectory || path.join(process.cwd(), 'cache'),
      adaptiveThresholds: config?.adaptiveThresholds !== undefined ? config.adaptiveThresholds : true
    };

    // Create cache directory if it doesn't exist
    if (!fs.existsSync(this.config.cacheDirectory)) {
      fs.mkdirSync(this.config.cacheDirectory, { recursive: true });
    }

    // Initialize selector history for categories
    const categories = ['Sniper', 'Gem Spotter', 'Early Mover'];
    const selectorTypes = [
      'categoryButton', 'filterButton', 'winRateInput', 
      'pnlInput', 'tradesInput', 'submitButton'
    ];

    categories.forEach(category => {
      this.selectorHistory[category] = {};
      selectorTypes.forEach(type => {
        this.selectorHistory[category][type] = {
          selector: '',
          successCount: 0,
          failCount: 0,
          lastSuccess: null,
          lastFail: null
        };
      });
    });

    // Load cached wallet data if available
    this.loadWalletCache();

    // Validate config
    this.validateConfig();
  }

  /**
   * Get current configuration
   */
  getConfig(): ChainEDGEConfig {
    return this.config;
  }

  /**
   * Validate configuration parameters
   */
  private validateConfig(): void {
    if (!this.config.username || !this.config.password) {
      throw new Error('ChainEDGE username and password are required');
    }

    // At least one wallet category must be enabled
    if (!this.config.walletCategories.sniper && 
        !this.config.walletCategories.gemSpotter && 
        !this.config.walletCategories.earlyMover) {
      throw new Error('At least one wallet category must be enabled');
    }

    // At least one timeframe filter must be enabled
    if (!this.config.timeframeFilters.fastTimeframe && 
        !this.config.timeframeFilters.slowTimeframe) {
      throw new Error('At least one timeframe filter must be enabled');
    }

    // Validate target success rate
    if (this.config.targetSuccessRate.min < 0 || 
        this.config.targetSuccessRate.max > 100 ||
        this.config.targetSuccessRate.min > this.config.targetSuccessRate.max) {
      throw new Error('Invalid target success rate range');
    }
  }

  /**
   * Initialize the scraper
   */
  async initialize(): Promise<boolean> {
    try {
      logger.info('Initializing ChainEDGE scraper');

      // Launch browser with stealth mode for better detection avoidance
      this.browser = await puppeteer.launch({
        headless: false, // Change to false to see the browser in action
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--disable-infobars',
          '--window-size=1920,1080',
          '--disable-gpu',
          '--disable-extensions'
        ],
        ignoreHTTPSErrors: true
      });

      // Create a new page
      this.page = await this.browser.newPage();

      // Set user agent to avoid detection
      await this.page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.84 Safari/537.36');

      // Set viewport size
      await this.page.setViewport({ width: 1920, height: 1080 });

      // Enable stealth mode
      await this.page.evaluateOnNewDocument(() => {
        // Hide webdriver
        Object.defineProperty(navigator, 'webdriver', {
          get: () => false
        });

        // Hide Chrome
        window.navigator.chrome = {
          runtime: {} as any
        };

        // Hide Automation
        window.navigator.languages = ['en-US', 'en'];

        // Overwrite permissions
        const originalQuery = window.navigator.permissions.query;
        window.navigator.permissions.query = (parameters: any) => {
          return (parameters.name === 'notifications' 
            ? Promise.resolve({ state: Notification.permission }) 
            : originalQuery(parameters)) as any;
        };
      });

      // Log in to ChainEDGE
      await this.login();

      logger.info('ChainEDGE scraper initialized successfully');
      return true;
    } catch (error) {
      logger.error('Failed to initialize ChainEDGE scraper:', error instanceof Error ? error.message : String(error));
      await this.cleanup();
      return false;
    }
  }

  /**
   * Log in to ChainEDGE
   */
  private async login(): Promise<void> {
    if (!this.page) {
      throw new Error('Browser not initialized');
    }

    try {
      logger.info('Logging in to ChainEDGE');

      // Navigate to the login page with next parameter
      await this.page.goto(`${this.config.baseUrl}/login/?next=/`, {
        waitUntil: 'networkidle2',
        timeout: 60000
      });

      // Take screenshot for debugging
      await this.page.screenshot({ path: 'login-page.png' });
      logger.info('Saved login page screenshot to login-page.png');

      // Wait for login form to load - add more selector variations
      await this.page.waitForSelector('input[type="email"], input[name="email"], input#email, input[placeholder*="Email"], input[placeholder*="email"]', { timeout: 10000 });

      // Add delay to ensure page is ready
      await this.page.waitForTimeout(1000);

      // Fill in login form - adjust selectors as needed
      const emailSelector = 'input[type="email"], input[name="email"], input#email, input[placeholder*="Email"], input[placeholder*="email"]';
      await this.page.type(emailSelector, this.config.username);

      const passwordSelector = 'input[type="password"], input[name="password"], input#password, input[placeholder*="Password"], input[placeholder*="password"]';
      await this.page.type(passwordSelector, this.config.password);

      // Add delay before clicking
      await this.page.waitForTimeout(1000);

      // Click login button with more options
      const loginButtonSelector = 'button[type="submit"], button:contains("Sign In"), button:contains("Login"), button.login-button, input[type="submit"]';

      // Take screenshot before clicking login
      await this.page.screenshot({ path: 'before-login-click.png' });

      await Promise.all([
        this.page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 60000 }).catch(() => {
          logger.warn('Navigation timeout after login attempt - continuing anyway');
        }),
        this.page.click(loginButtonSelector)
      ]);

      // Add extra wait time for potential redirects after login
      await this.page.waitForTimeout(5000);

      // Take screenshot after login attempt
      await this.page.screenshot({ path: 'after-login.png' });

      // Check if login was successful - updated for more potential dashboard elements
      const isLoggedIn = await this.page.evaluate(() => {
        // Look for elements that would indicate successful login
        return !document.querySelector('input[type="password"]') && 
               (document.querySelector('.user-profile, .dashboard, .nav-dashboard, .logged-in, .account-info, .user-menu, .profile-section') !== null);
      });

      if (!isLoggedIn) {
        // Take screenshot of the failed login page
        await this.page.screenshot({ path: 'login-failed.png' });
        throw new Error('Login failed - could not verify successful login. See login-failed.png');
      }

      this.isLoggedIn = true;
      logger.info('Successfully logged in to ChainEDGE');
    } catch (error) {
      logger.error('Failed to log in to ChainEDGE:', error instanceof Error ? error.message : String(error));
      throw new Error(`Authentication failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Start scheduled scraping
   */
  async startScheduledScraping(): Promise<void> {
    if (this.isRunning) {
      logger.warn('Scraper is already running');
      return;
    }

    try {
      this.isRunning = true;

      // Initial scrape
      await this.scrapeWallets();

      // Set up interval for recurring scrapes
      setInterval(async () => {
        if (!this.isRunning) return;

        try {
          // Only run if no active scraping jobs
          if (this.activeScrapingJobs === 0) {
            await this.scrapeWallets();
          } else {
            logger.warn(`Skipping scheduled scrape - ${this.activeScrapingJobs} active scraping jobs`);
          }
        } catch (error) {
          logger.error('Error in scheduled scrape:', error instanceof Error ? error.message : String(error));
          
          // Try to reinitialize if needed
          if (!this.isLoggedIn || !this.page) {
            logger.info('Attempting to reinitialize scraper...');
            await this.initialize();
          }
        }
      }, this.config.scrapeInterval);

      logger.info(`Scheduled scraping started with ${this.config.scrapeInterval / 60000} minute interval`);
    } catch (error) {
      this.isRunning = false;
      logger.error('Failed to start scheduled scraping:', error instanceof Error ? error.message : String(error));
    }
  }

  /**
   * Stop scheduled scraping
   */
  async stopScheduledScraping(): Promise<void> {
    this.isRunning = false;
    logger.info('Scheduled scraping stopped');
  }

  /**
   * Scrape wallet data from ChainEDGE
   */
  async scrapeWallets(): Promise<void> {
    if (!this.isLoggedIn || !this.page) {
      await this.initialize();
    }

    try {
      logger.info('Starting to scrape wallet data from ChainEDGE');

      // Get enabled wallet categories
      const categories: string[] = [];
      if (this.config.walletCategories.sniper) categories.push('Sniper');
      if (this.config.walletCategories.gemSpotter) categories.push('Gem Spotter');
      if (this.config.walletCategories.earlyMover) categories.push('Early Mover');

      // Process each category
      if (this.config.parallelProcessing) {
        // Process categories in parallel
        await Promise.all(categories.map(category => this.scrapeWalletsByCategory(category)));
      } else {
        // Process categories sequentially
        for (const category of categories) {
          await this.scrapeWalletsByCategory(category);
        }
      }

      // After all categories are processed, check for wallets appearing in multiple categories
      this.identifyCrossCategoryWallets();

      // Adjust thresholds if adaptive thresholds are enabled
      if (this.config.adaptiveThresholds) {
        await this.adjustThresholdsBasedOnResults();
      }

      // Save wallet cache
      this.saveWalletCache();

      logger.info(`Wallet data scraping completed. Stats: ${JSON.stringify(this.stats)}`);
    } catch (error) {
      logger.error('Error scraping wallet data:', error instanceof Error ? error.message : String(error));
      throw error;
    }
  }

  /**
   * ENHANCED: Scrape wallets for a specific category with improved resilience and accuracy
   */
  private async scrapeWalletsByCategory(category: string): Promise<void> {
    if (!this.page) return;

    // Track job stats
    const jobStats: ScrapingJobStats = {
      startTime: new Date(),
      endTime: null,
      category,
      walletsFound: 0,
      highQualityWallets: 0,
      errors: [],
      success: false,
      currentSuccessRate: null
    };

    this.activeScrapingJobs++;
    this.stats.scrapingJobs.push(jobStats);

    try {
      logger.info(`Scraping ${category} wallets`);

      let retryCount = 0;
      let success = false;

      // Retry loop with exponential backoff
      while (!success && retryCount < this.config.maxRetries) {
        try {
          // If retry, wait with exponential backoff
          if (retryCount > 0) {
            const delay = this.config.retryDelay * Math.pow(2, retryCount - 1);
            logger.info(`Retry ${retryCount}/${this.config.maxRetries} for ${category} after ${delay}ms`);
            await this.page.waitForTimeout(delay);
          }
          
          // Navigate to main dashboard page
          await this.page.goto(`${this.config.baseUrl}/dashboard`, { 
            waitUntil: 'networkidle2',
            timeout: 60000
          });
          
          // Take a screenshot of the dashboard for debugging
          const screenshotPath = `dashboard-${category}-${new Date().toISOString().replace(/:/g, '-')}.png`;
          await this.page.screenshot({ path: screenshotPath });
          logger.info(`Saved dashboard screenshot to ${screenshotPath}`);
          
          // Verify we're on the dashboard page
          const onDashboard = await this.verifyCurrentPage('dashboard');
          if (!onDashboard) {
            throw new Error('Not on dashboard page');
          }
          
          // Wait for the page to fully load with adaptive selector strategy
          const contentSelector = await this.findWorkingSelector([
            '.content', '.dashboard', '.main-content', '.container', 
            '.filter-button', '.category-filter', '[data-category]',
            // Add structure-based selectors that are less likely to change
            'div[class*="dashboard"]', 'div[class*="content"]', 'main', 'div[role="main"]'
          ], 'dashboardContent');
          
          if (!contentSelector) {
            throw new Error('Could not find dashboard content');
          }
          
          await this.page.waitForSelector(contentSelector, { timeout: 15000 }).catch(() => {
            logger.warn('Could not find expected dashboard elements - continuing anyway');
          });
          
          // Wait for a moment to ensure the dashboard is fully loaded
          await this.page.waitForTimeout(3000);
          
          // ENHANCED: Use adaptive selector system to find category filter elements
          const filterResult = await this.findAndClickCategoryFilter(category);
          if (!filterResult.success) {
            throw new Error(`Could not select ${category} filter: ${filterResult.reason}`);
          }
          
          // Wait for results to load
          await this.page.waitForTimeout(2000);
          
          // Take screenshot after category selection
          await this.page.screenshot({ path: `after-category-selection-${category}.png` });
          
          // ENHANCED: Use adaptive selector system to find and click filter button
          const filterButtonResult = await this.findAndClickFilterButton();
          if (!filterButtonResult.success) {
            throw new Error(`Could not click filter button: ${filterButtonResult.reason}`);
          }
          
          // Wait for filter dialog to appear with adaptive selector strategy
          await this.page.waitForSelector('input, form, .filter-form, .modal', { timeout: 15000 }).catch(() => {
            logger.warn('Could not find filter form elements - continuing anyway');
          });
          
          // Take screenshot of filter dialog
          await this.page.screenshot({ path: `filter-dialog-${category}.png` });
          
          // ENHANCED: Adaptively fill filter form with optimized values based on target success rate
          const filledFields = await this.fillFilterForm(category);
          logger.info(`Filter fields filled: ${filledFields.join(', ')}`);
          
          // Take screenshot after filling the filter form
          await this.page.screenshot({ path: `filter-form-filled-${category}.png` });
          
          // ENHANCED: Submit the filter form with adaptive selector system
          const submitResult = await this.submitFilterForm();
          if (!submitResult.success) {
            throw new Error(`Could not submit filter form: ${submitResult.reason}`);
          }
          
          // Wait for results to load with random delay to avoid detection
          const randomWait = 2000 + Math.random() * 1000;
          await this.page.waitForTimeout(randomWait);
          
          // Take screenshot of results
          await this.page.screenshot({ path: `results-${category}.png` });
          
          // ENHANCED: Extract wallet data with improved robustness
          const wallets = await this.extractWalletData(category);
          this.stats.totalWalletsSeen += wallets.length;
          jobStats.walletsFound = wallets.length;
          
          logger.info(`Found ${wallets.length} ${category} wallets`);
          
          // ENHANCED: Apply dynamic filtering based on target success rate
          const highQualityWallets = await this.filterHighQualityWallets(wallets, category);
          this.stats.highValueWallets += highQualityWallets.length;
          jobStats.highQualityWallets = highQualityWallets.length;
          
          logger.info(`Found ${highQualityWallets.length} high quality ${category} wallets`);
          
          // ENHANCED: Process wallets with success prediction and cross-referencing
          await this.processWalletsBatch(highQualityWallets, category);
          
          // Mark success
          success = true;
          
          // Update category success rate
          const processedWallets = await ExternalWallet.find({ category });
          if (processedWallets.length > 0) {
            const successRateSum = processedWallets.reduce((sum, wallet) => sum + wallet.winRate, 0);
            this.categorySuccessRates[category] = successRateSum / processedWallets.length;
            jobStats.currentSuccessRate = this.categorySuccessRates[category];
          }
          
          logger.info(`Processed ${highQualityWallets.length} ${category} wallets with estimated success rate: ${this.categorySuccessRates[category].toFixed(2)}%`);
        } catch (error) {
          retryCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          logger.error(`Error (attempt ${retryCount}/${this.config.maxRetries}) scraping ${category} wallets: ${errorMessage}`);
          
          // If we still have retries, take a screenshot and continue
          if (retryCount < this.config.maxRetries) {
            await this.page.screenshot({ path: `error-${category}-retry${retryCount}.png` });
          } else {
            // Log the error to job stats
            jobStats.errors.push(errorMessage);
            throw error; // Re-throw to be caught by outer try-catch
          }
        }
      }

      // If we exit the loop successfully
      if (success) {
        jobStats.success = true;
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to scrape ${category} wallets after ${this.config.maxRetries} attempts: ${errorMessage}`);
      jobStats.errors.push(errorMessage);
    } finally {
      // Update job stats
      jobStats.endTime = new Date();
      this.activeScrapingJobs--;
    }
  }

  /**
   * ENHANCED: Process a batch of wallets efficiently
   */
  private async processWalletsBatch(wallets: EnhancedWalletData[], category: string): Promise<void> {
    logger.info(`Processing batch of ${wallets.length} ${category} wallets`);

    // Group wallets into 10 or fewer at a time to avoid overwhelming the database
    const batchSize = 10;
    const batches = [];
    for (let i = 0; i < wallets.length; i += batchSize) {
      batches.push(wallets.slice(i, i + batchSize));
    }

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      logger.info(`Processing wallet batch ${i+1}/${batches.length} with ${batch.length} wallets`);

      // Process each wallet in the batch
      const promises = batch.map(async (wallet) => {
        try {
          // Check cache first
          const cacheKey = wallet.address;
          if (!cacheKey) return;
          
          const now = Date.now();
          const cached = this.walletCache.get(cacheKey);
          
          // If we have a recent cache hit, use it
          if (cached && (now - cached.timestamp) < this.config.dataCacheTTL) {
            logger.info(`Using cached data for wallet ${wallet.address}`);
            await this.saveWallet({...cached.data, category});
            return;
          }
          
          // Add category cross-reference
          this.trackWalletCategory(wallet.address, category);
          
          // ENHANCED: Predict success rate based on wallet metrics
          wallet.predictedSuccessRate = this.predictWalletSuccessRate(wallet);
          wallet.confidenceScore = this.calculateWalletConfidenceScore(wallet);
          
          // Save wallet to database
          await this.saveWallet(wallet);
          
          // Get and process transactions if this is a high-confidence wallet
          if (wallet.confidenceScore && wallet.confidenceScore > 70 && wallet.address) {
            await this.getWalletTransactions(wallet.address);
          }
          
          // Cache wallet data
          if (wallet.address) {
            this.walletCache.set(wallet.address, {
              data: wallet,
              timestamp: now
            });
          }
          
          this.stats.walletsProcessed++;
          
          // Add to known successful wallets if win rate is within target
          if (wallet.address && wallet.winRate && 
              wallet.winRate >= this.config.targetSuccessRate.min && 
              wallet.winRate <= this.config.targetSuccessRate.max) {
            this.knownSuccessfulWallets.add(wallet.address);
          }
        } catch (error) {
          logger.error(`Error processing wallet ${wallet.address}:`, error instanceof Error ? error.message : String(error));
        }
      });

      // Wait for all wallets in the batch to be processed
      await Promise.all(promises);
    }
  }

  /**
   * ENHANCED: Track wallet category for cross-referencing
   */
  private trackWalletCategory(address: string | undefined, category: string): void {
    if (!address) return;
    
    const categories = this.crossCategoryWallets.get(address) || [];
    if (!categories.includes(category)) {
      categories.push(category);
      this.crossCategoryWallets.set(address, categories);
    }
  }

  /**
   * ENHANCED: Identify wallets that appear in multiple categories
   */
  private identifyCrossCategoryWallets(): void {
    logger.info('Identifying cross-category wallets');

    const crossCategoryCount = {
      'Sniper,Gem Spotter': 0,
      'Sniper,Early Mover': 0,
      'Gem Spotter,Early Mover': 0,
      'Sniper,Gem Spotter,Early Mover': 0