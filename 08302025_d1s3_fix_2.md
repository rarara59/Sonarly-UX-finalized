# Fix Session 2: Resource Cleanup - Promise/Memory Leak Fix

**Return to Claude Code with this exact prompt:**

```
I need to fix promise and memory leaks that cause 85% hourly memory growth during sustained operation.

PROBLEM IDENTIFIED: Failed requests accumulate without cleanup, unhandled promise rejections cause memory leaks.

PREREQUISITE: Fix Session 1 Connection Pool COMPLETED - Connection pool now properly manages resources

CURRENT SYSTEM STATUS:
- Connection pool resource management fixed
- Memory growth rate: 85% per hour (target: <2% per hour)
- Unhandled promise rejections during network failures
- Failed request cleanup not happening properly

## SINGLE FOCUS: Fix Promise and Memory Leak Issues

TASK: Implement proper request lifecycle management and cleanup to eliminate memory leaks during sustained operation.

### Explicit Files to Modify:
**Primary**: `src/detection/transport/rpc-connection-pool.js` - Add request lifecycle management
**Secondary**: `scripts/test-memory-stability.js` - Create memory leak validation

### Incremental Implementation Process:

**Step 1**: Add RequestManager class for request lifecycle tracking
**Step 2**: Integrate request cleanup in RpcConnectionPool.call() method
**Step 3**: Test memory usage with short-term load (2 minutes)
**Step 4**: Test memory stability with medium-term load (5 minutes)  
**Step 5**: Validate memory growth rate under sustained load

### Clear Success Criteria:

**Memory Management Requirements**:
- Memory growth rate under 2% per hour during sustained operation
- No unhandled promise rejections during network failures
- Failed requests properly cleaned up within 5 seconds
- Request tracking overhead under 1MB for 1000 concurrent requests
- Memory usage stabilizes after request completion

**Request Lifecycle Requirements**:
- All active requests tracked with unique IDs
- Request cleanup happens on success, failure, and timeout
- Aborted requests release all associated resources
- No hanging promises after request completion
- Request timeout triggers automatic cleanup

**Error Handling Requirements**:
- Network failures don't leave hanging promises
- Timeout scenarios properly clean up request state
- AbortController signal propagates to all request components
- Failed cleanup operations don't prevent other cleanups
- Cleanup errors logged but don't crash system

### Implementation Requirements:

**Request Manager Design**:
- Track active requests with Map<requestId, AbortController>
- Automatic timeout with AbortController after 5000ms
- Cleanup method removes request from tracking and aborts controller
- Promise.race pattern for timeout vs operation completion
- Graceful cleanup on system shutdown

**Integration Points**:
- Wrap all RPC calls with request lifecycle management
- Generate unique request IDs for tracking
- Ensure cleanup happens in all code paths (success, error, timeout)
- Add request cleanup to existing error handling

### Testing Requirements:
- Memory usage measured every 15 seconds during testing
- Test with realistic failure rates (10-20% network errors)
- Verify cleanup happens for successful, failed, and timed-out requests
- Measure memory usage before, during, and after load testing
- Test system shutdown cleans up all pending requests

### Expected Changes:

**Modified File**: `src/detection/transport/rpc-connection-pool.js`
- Add RequestManager class with cleanup capabilities
- Modify call() method to use request lifecycle management
- Add AbortController integration for timeout handling
- Implement proper cleanup in all error paths
- Add shutdown method for graceful cleanup

**New File**: `scripts/test-memory-stability.js`
- Test memory usage during 5-minute sustained load
- Measure memory growth rate per hour
- Validate cleanup effectiveness during various failure scenarios
- Report memory usage patterns and leak detection

### Performance Requirements to Measure:

**Memory Stability Metrics**:
- Memory growth rate: Target <2% per hour
- Memory usage after cleanup: Should return to baseline within 60 seconds
- Request tracking overhead: <100KB for 100 concurrent requests
- Cleanup completion time: <100ms per request cleanup

**Request Management Metrics**:
- Unhandled promise rejection count: 0 during testing
- Request cleanup success rate: 100% for all request types
- Timeout handling accuracy: Timeouts trigger within 5100ms (5000ms + tolerance)
- Resource leak detection: No hanging AbortControllers or Map entries

### If Memory Leak Fix Fails:
1. Identify specific leak source (promises, event listeners, timers)
2. Test RequestManager in isolation before integration
3. Verify AbortController cleanup works for all request scenarios
4. Do not proceed to backpressure implementation until memory stable

CRITICAL REQUIREMENTS:
- Memory growth rate must be under 2% per hour for production readiness
- Zero unhandled promise rejections during network failures
- All request resources cleaned up within 5 seconds of completion/failure
- Request tracking adds minimal memory overhead
- System handles cleanup gracefully during shutdown

SUCCESS CRITERIA SUMMARY:
- Memory growth rate reduced from 85%/hour to <2%/hour
- No unhandled promise rejections during sustained operation
- Request cleanup working for all success/failure/timeout scenarios
- Memory usage stabilizes after load testing completion
- Ready for Fix Session 3 (Backpressure Implementation)
```

## Your Post-Fix Process

After Claude Code completes resource cleanup implementation:

**Step 1: Test Memory Stability**
```bash
# Run memory stability test
node scripts/test-memory-stability.js

# Monitor memory usage during test
watch -n 5 'ps aux | grep node | grep -v grep | awk "{print \$6}"'

# Check for memory growth rate improvement
grep -i "memory.*growth.*rate" memory-stability-results.txt
```

**Step 2: Validate Promise Cleanup**
```bash
# Check for unhandled promise rejections
node -e "
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled promise rejection:', reason);
});
// Run test with promise rejection monitoring
" 2>&1 | tee promise-rejection-log.txt

# Should show 0 unhandled rejections
wc -l promise-rejection-log.txt
```

**Step 3: Document Memory Fix Results**
```bash
# Record memory improvement
echo "Fix Session 2 Memory Cleanup: $(date)" >> development.log
echo "Memory growth rate: $(grep -o '[0-9]*\.[0-9]*%.*hour' memory-stability-results.txt)" >> development.log

# Commit memory leak fix
git add src/detection/transport/rpc-connection-pool.js scripts/test-memory-stability.js
git commit -m "Fix Session 2: Resource cleanup - Request lifecycle management eliminates memory leaks"
```

This focused approach addresses only the memory leak and promise cleanup issues without attempting to solve multiple complex problems simultaneously.